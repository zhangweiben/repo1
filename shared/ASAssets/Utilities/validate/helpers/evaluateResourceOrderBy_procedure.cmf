<?xml version="1.1" encoding="UTF-8"?>
<!-- salt:44831da2-fa57-48b1-b3e8-4297d727cb06 -->
<metadata name="evaluateResourceOrderBy" path="/shared/ASAssets/Utilities/validate/helpers/evaluateResourceOrderBy" type="PROCEDURE" subtype="SQL_SCRIPT_PROCEDURE" changeToken="0">
  <annotation>evaluateResourceOrderBy

	This procedure is used to determine whether &quot;order by&quot; is being used within the SQL script except when used
		within the context of analytical functions which is valid.

	Release:	Modified Date:	Modified By:		DV Version:		Reason:
	2019.200	04/19/2019		Mike Tinius			7.0.8			Created new to test for &quot;order by&quot;

	(c) 2017 TIBCO Software Inc.  All rights reserved.
	
	Except as specified below, this software is licensed pursuant to the Eclipse Public License v. 1.0.
	The details can be found in the file LICENSE.
	
	The following proprietary files are included as a convenience, and may not be used except pursuant
	to valid license to Composite Information Server or TIBCO® Data Virtualization Server:
	csadmin-XXXX.jar, csarchive-XXXX.jar, csbase-XXXX.jar, csclient-XXXX.jar, cscommon-XXXX.jar,
	csext-XXXX.jar, csjdbc-XXXX.jar, csserverutil-XXXX.jar, csserver-XXXX.jar, cswebapi-XXXX.jar,
	and customproc-XXXX.jar (where -XXXX is an optional version number).  Any included third party files
	are licensed under the terms contained in their own accompanying LICENSE files, generally named .LICENSE.txt.
	
	This software is licensed AS-IS. Support for this software is not covered by standard maintenance agreements with TIBCO.
	If you would like to obtain assistance with this software, such assistance may be obtained through a separate paid consulting
	agreement with TIBCO.</annotation>
  <parameters>
    <parameter name="debug" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="inSqlScript" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="containsOrderBy" direction="OUT" nullable="true">
      <datatype name="BIT" type="INTEGER" minValue="0" maxValue="1"/>
    </parameter>
  </parameters>
  <security>
    <owner user="admin" domain="composite"/>
    <privilege group="all" domain="composite" privileges="READ"/>
  </security>
  <dependency target="/lib/debug/Print" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="textToPrint" direction="IN">
        <datatype referenceDefinitionSet="/lib/util/System" referenceType="Text" type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/string/encodedValues" type="DEFINITION_SET">
    <datatype name="Tree" type="TREE" refId="1"></datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/string/findOpenClosePair" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="sqlScript" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="begPos" direction="IN">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
      <element name="codingList" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="openingDelim" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="closingDelim" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="trimText" direction="IN">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
      <element name="openingDelimPos" direction="OUT">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
      <element name="closingDelimPos" direction="OUT">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
      <element name="extractedScript" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="sqlScriptEncoded" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="extractedScriptBefore" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="extractedScriptAfter" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/string/getCodedString" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="inCodingType" direction="IN">
        <datatype type="STRING" minLength="1" maxLength="1"/>
      </element>
      <element name="inEncodingActions" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="codingList" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="inString" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="inModuleNameInvoking" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="inDebug" direction="IN">
        <datatype type="STRING" minLength="1" maxLength="1"/>
      </element>
      <element name="inModuleQualifer" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="outString" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/time/getCurrentTimestamp" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="currentTS" direction="OUT">
        <datatype type="DATETIME"/>
      </element>
    </datatype>
  </dependency>
  <attribute name="Script" type="STRING">/*
	evaluateResourceOrderBy

	This procedure is used to determine whether &quot;order by&quot; is being used within the SQL script except when used
		within the context of analytical functions which is valid.

	Release:	Modified Date:	Modified By:		DV Version:		Reason:
	2019.200	04/19/2019		Mike Tinius			7.0.8			Created new to test for &quot;order by&quot;

	(c) 2017 TIBCO Software Inc.  All rights reserved.
	
	Except as specified below, this software is licensed pursuant to the Eclipse Public License v. 1.0.
	The details can be found in the file LICENSE.
	
	The following proprietary files are included as a convenience, and may not be used except pursuant
	to valid license to Composite Information Server or TIBCO® Data Virtualization Server:
	csadmin-XXXX.jar, csarchive-XXXX.jar, csbase-XXXX.jar, csclient-XXXX.jar, cscommon-XXXX.jar,
	csext-XXXX.jar, csjdbc-XXXX.jar, csserverutil-XXXX.jar, csserver-XXXX.jar, cswebapi-XXXX.jar,
	and customproc-XXXX.jar (where -XXXX is an optional version number).  Any included third party files
	are licensed under the terms contained in their own accompanying LICENSE files, generally named .LICENSE.txt.
	
	This software is licensed AS-IS. Support for this software is not covered by standard maintenance agreements with TIBCO.
	If you would like to obtain assistance with this software, such assistance may be obtained through a separate paid consulting
	agreement with TIBCO.

*/
PROCEDURE evaluateResourceOrderBy(
	IN debug					CHAR(1),
	IN inSqlScript				LONGVARCHAR,
	OUT containsOrderBy			BIT	
)
BEGIN
	DECLARE moduleName				VARCHAR DEFAULT &apos;evaluateResourceOrderBy&apos;;
	DECLARE debug4					CHAR(1) DEFAULT &apos;N&apos;;
	DECLARE debugPrintSize			INTEGER DEFAULT 63000;
	DECLARE trimText				INTEGER DEFAULT 0;
	DECLARE duration				VARCHAR;
	DECLARE currentTS				TIMESTAMP;
	DECLARE sectionStartTime		TIMESTAMP;
	DECLARE sqlScript				LONGVARCHAR DEFAULT inSqlScript;
	DECLARE actionTaken				BOOLEAN;
	DECLARE word, parentword 		LONGVARCHAR default &apos;&apos;;
	DECLARE grandparentword			LONGVARCHAR DEFAULT &apos;&apos;;
	DECLARE wordcount 				INTEGER DEFAULT 0;
	DECLARE fromPos, selectPos		INTEGER DEFAULT 0;
	DECLARE begPos, endPos, asPos	INTEGER;
	DECLARE ch						CHAR(1);
	DECLARE len						INTEGER;
	DECLARE i,x,y					INTEGER;
	DECLARE pos1,pos2				INTEGER;
	DECLARE pos1end,pos3,pos4		INTEGER;
	DECLARE moreToDo1				BOOLEAN DEFAULT true;
	DECLARE object					LONGVARCHAR;
	DECLARE objectList1				LONGVARCHAR;
	DECLARE expression1				VARCHAR;
	DECLARE explen1					INTEGER;
	-- Analytical Function List in the syntax of:
	--		ANALYTICAL_FUNCTION ( [expression] ) OVER ( [PARTITION BY | ORDER BY] expression [, ...])
	--		ANALYTICAL_FUNCTION ( [expression] ) WITHIN GROUP ( ORDER BY expression [, ...] ) OVER ( [PARTITION BY | ORDER BY] expression [, ...])
	--		ANALYTICAL_FUNCTION ( [ PARTITION BY expression [, ...] ] ORDER BY expression [ ASC | DESC ] [ NULLS { FIRST | LAST } [, ...])
	DECLARE analyticalFunctionList	VARCHAR(1024) DEFAULT &apos;,AVG,COUNT,MIN,MAX,ROW_NUMBER,RANK,MEDIAN,CORR,COVAR_POP,COVAR_SAMP&apos;||
		&apos;,CUME_DIST,DENSE_RANK,FIRST,FIRST_VALUE,LAG,LAST,LAST_VALUE,LEAD,LISTAGG,NTH_VALUE,NTILE,PERCENT_RANK,PERCENTILE,PERCENTILE_APPROX,PERCENTILE_CONT,PERCENTILE_DISC,RATIO_TO_REPORT&apos;||
		&apos;,REGR_AVGX,REGR_AVGY,REGR_COUNT,REGR_INTERCEPT,REGR_R2,REGR_SLOPE,REGR_SXX,REGR_SXY,REGR_SXY,REGR_SYY,STDDEV,STDDEV_POP,STDDEV_SAMP,VAR_POP,VAR_SAMP,VARIANCE&apos;||
		&apos;,&apos;;

	DECLARE analyticalFunction		VARCHAR;
	DECLARE analyticalFunctions		LONGVARCHAR;
	DECLARE analyticalFunctionType	VARCHAR;
	DECLARE analyticalFuncCount		INTEGER;
	DECLARE analyticalFuncEnd		INTEGER;
	DECLARE analyticalFuncPart2		INTEGER;
	DECLARE continueAnalyticalLoop1	BOOLEAN;
	DECLARE continueAnalyticalLoop2	BOOLEAN;
	DECLARE encodedComma			VARCHAR DEFAULT /shared/ASAssets/Utilities/string/encodedValues.encodedComma;  				-- _002C -- &apos;,&apos; comma
	DECLARE encodedSpace			VARCHAR DEFAULT /shared/ASAssets/Utilities/string/encodedValues.encodedSpace;  				-- _002E -- &apos; &apos; space
	DECLARE leftParenPos			INTEGER;
	DECLARE rightParenPos			INTEGER;
	DECLARE extractedScript			LONGVARCHAR;
	DECLARE extractedScriptBefore	LONGVARCHAR; 	-- This is the first extracted &quot;expression&quot; before the opening pair &quot;exp_before P1 ( expression ) exp_after&quot;.
	DECLARE extractedScriptAfter	LONGVARCHAR; 	-- This is the first extracted &quot;expression&quot; after the closing pair &quot;exp_before P1 ( expression ) exp_after&quot;.
	DECLARE operationFound			BOOLEAN;
	DECLARE operandFound			BOOLEAN;
	DECLARE sqlScriptMod			LONGVARCHAR;
	DECLARE otherText				BOOLEAN;
	DECLARE doEncoding				BOOLEAN DEFAULT false;

		SET containsOrderBy = 0;

		/************************************************************************
		 *  Place Double Quotes around ANALYTICAL_FUNCTION() OVER ( ) AS COLUMN_ALIAS
		*************************************************************************/
		-- Analytical Function List in the syntax of:
		--		ANALYTICAL_FUNCTION ( [expression] ) OVER ( [PARTITION BY | ORDER BY] expression [, ...])
		--		ANALYTICAL_FUNCTION ( [expression] ) WITHIN GROUP ( ORDER BY expression [, ...] ) OVER ( [PARTITION BY | ORDER BY] expression [, ...])
		--		ANALYTICAL_FUNCTION ( [ PARTITION BY expression [, ...] ] ORDER BY expression [ ASC | DESC ] [ NULLS { FIRST | LAST } [, ...])
		if (debug = &apos;Y&apos;) then
			call /shared/ASAssets/Utilities/&quot;time&quot;/getCurrentTimestamp(sectionStartTime);
		end if;

		-- Convert CR,LF,TAB to space
		set sqlScript = inSqlScript;
		set sqlScript = TRIM(REPLACE(sqlScript,chr(13),&apos; &apos;)); 	-- Carriage return
		set sqlScript = TRIM(REPLACE(sqlScript,chr(10),&apos; &apos;)); 	-- Line Feed
		set sqlScript = TRIM(REPLACE(sqlScript,chr(9), &apos; &apos;));	-- Tab
		-- Insure there are spaces around left and right parenthesis
		set sqlScript = REPLACE(sqlScript, &apos;)&apos;, &apos; ) &apos;);
		set sqlScript = REPLACE(sqlScript, &apos;(&apos;, &apos; ( &apos;);
		-- Insure there are spaces around commas
		set sqlScript = REPLACE(sqlScript, &apos;,&apos;, &apos; , &apos;);

		set actionTaken = false;
		-- Reduce the number of double spaces to a single space
		while (INSTR(sqlScript, &apos;  &apos;) &gt; 0) do
			set actionTaken = true;
			set sqlScript = REPLACE(sqlScript, &apos;  &apos;, &apos; &apos;);
		end while;

		-- Convert the string WITHIN GROUP to WITHIN_GROUP so that it is a single word for parsing purposes.
		--	WITHIN GROUP is used by: LISTAGG, PERCENTILE_CONT, PERCENTILE_DISC
		set pos1 = INSTR(UPPER(sqlScript), &apos; WITHIN GROUP &apos;);
		while (pos1 &gt; 0) do
			set sqlScript = SUBSTRING(sqlScript, 1, pos1-1) || &apos; WITHIN_GROUP &apos;|| SUBSTRING(sqlScript,pos1+14);
			set pos1 = INSTR(UPPER(sqlScript), &apos; WITHIN GROUP &apos;);
		end while;
		-- Convert the string FROM FIRST to FROM_FIRST so that it is a single word for parsing purposes.
		--	FROM FIRST is used by: NTH_VALUE
		set pos1 = INSTR(UPPER(sqlScript),&apos; FROM FIRST &apos;);
		while (pos1 &gt; 0) do
			set sqlScript = SUBSTRING(sqlScript, 1, pos1-1) || &apos; FROM_FIRST &apos;|| SUBSTRING(sqlScript,pos1+12);
			set pos1 = INSTR(UPPER(sqlScript),&apos; FROM FIRST &apos;);
		end while;
		-- Convert the string FROM LAST to FROM_LAST so that it is a single word for parsing purposes.
		--	FROM LAST is used by: NTH_VALUE
		set pos1 = INSTR(UPPER(sqlScript),&apos; FROM LAST &apos;);
		while (pos1 &gt; 0) do
			set sqlScript = SUBSTRING(sqlScript, 1, pos1-1) || &apos; FROM_LAST &apos;|| SUBSTRING(sqlScript,pos1+11);
			set pos1 = INSTR(UPPER(sqlScript),&apos; FROM LAST &apos;);
		end while;

		--   Example: &quot;ROW_NUMBER() over (partition by SOURCE_ID, A, B, ORDER BY C)&quot; AS SEQ
		SET analyticalFunctions = null;
		-- Extract the object from the list
		SET objectList1 = analyticalFunctionList;
		SET expression1 = &apos;,&apos;;
		SET explen1 = length(expression1);
		SET moreToDo1 = true;
		SET x = 0;
		WHILE (moreToDo1) DO
			-- Extract the source column type
			SET x = x + 1;
			SET object = null;
			IF (x = 1) THEN
				SET pos1 = INSTR(objectList1, expression1, 1, x);
				IF (pos1 &gt; 0) THEN
					SET object = SUBSTRING(objectList1, 1, pos1-1);
				ELSE
					IF (LENGTH(TRIM(objectList1)) &gt; 0) THEN
						SET object = objectList1;
					END IF;
					SET moreToDo1 = false;
				END IF;
			ELSE
				SET pos1 = INSTR(objectList1, expression1, 1, x-1);
				SET pos2 = INSTR(objectList1, expression1, 1, x);
				IF (pos1 &gt; 0 and pos2 &gt; 0) THEN
					SET object = SUBSTRING(objectList1, pos1+explen1, pos2-pos1-explen1);
				ELSEIF (pos1 &gt; 0 and pos2 = 0) THEN
					SET object = SUBSTRING(objectList1, pos1+explen1);
					SET moreToDo1 = false;
				ELSE
					SET moreToDo1 = false;
				END IF;
			END IF;
			SET object = TRIM(object);
			--CALL PRINT(&apos;object=&apos;||TRIM(NVL(object,&apos;  &apos;)));
			IF (object IS NOT NULL and LENGTH(TRIM(object)) &gt; 0) then
				set analyticalFunction = object;

				set endPos = 1;
				set analyticalFuncCount = 0;
				set continueAnalyticalLoop1 = true;
				while (continueAnalyticalLoop1) do
					/***************************************************************************************
						Get the position again looking for the next occurrence of the analytical function
					****************************************************************************************/
					set analyticalFuncCount = analyticalFuncCount + 1;
					if (debug = &apos;Y&apos;) then
						call print(moduleName||&apos; : PARSE ANALYTICAL FUNCTION: &apos;||RTRIM(NVL(analyticalFunction,&apos;  &apos;))||&apos;()  SEARCHING...count=&apos;||analyticalFuncCount);
					end if;
					set pos2 = 0;
					set pos3 = 0;
					set pos4 = 0;
					set pos1end = 0;
					set analyticalFuncEnd = 0;
					set analyticalFuncPart2 = 0;
					set analyticalFunctionType = &apos;&apos;;
					set pos1 = INSTR(UPPER(sqlScript),analyticalFunction||&apos; (&apos;, endPos);
					if (pos1 &gt; 0) then
						-- Find the end of the analytical function part1: analytical_func ( expression )
						--                                                                             ^-pos1end
						-- Search through the sql script to find the corresponding right paren ) for the starting left paren (
						-- This assumes there is only a single outer () pair such as P1(  P2 ( ) ).  This pattern is not supported in this context: P1 ( )  P2 ( )
						-- By finding the logical end to the analytical function part 1, is insures that the follow-on searches will have no issues 
						--		with embedded commas or other search text that might interfere with the rest of the searches.
						call /shared/ASAssets/Utilities/string/findOpenClosePair(sqlScript, pos1, encodedComma, &apos;(&apos;,&apos;)&apos;, trimText, leftParenPos, rightParenPos, extractedScript, sqlScriptMod, extractedScriptBefore, extractedScriptAfter);
						if (debug = &apos;Y&apos;) then
							call print(moduleName||&apos; :     &apos;||RTRIM(NVL(analyticalFunction,&apos;  &apos;))||&apos;(): VALIDATING...pos1:findOpenClosePair sqlScriptMod=[&apos;||SUBSTRING(RTRIM(NVL(sqlScriptMod,&apos;  &apos;)),1,debugPrintSize)||&apos;]&apos;);
						end if;
						if (rightParenPos &gt; 0) then
							set pos1end = rightParenPos;
						end if;
						if (sqlScriptMod is not null) then
							set sqlScript = sqlScriptMod;
						end if;

						-- Find the position of &apos; WITHIN_GROUP &apos; and/or &apos; OVER &apos;
						-- They both may exist in the same function for LISTAGG, PERCENTILE_CONT and PERCENTILE_DISC
						set pos2 = INSTR(UPPER(sqlScript),&apos; WITHIN_GROUP &apos;,pos1end);
						if (pos2 &gt; 0) then
							call /shared/ASAssets/Utilities/string/findOpenClosePair(sqlScript, pos2, encodedComma, &apos;(&apos;,&apos;)&apos;, trimText, leftParenPos, rightParenPos, extractedScript, sqlScriptMod, extractedScriptBefore, extractedScriptAfter);
							if (debug = &apos;Y&apos;) then
								call print(moduleName||&apos; :     &apos;||RTRIM(NVL(analyticalFunction,&apos;  &apos;))||&apos;() WITHIN GROUP(): VALIDATING...pos2:findOpenClosePair sqlScriptMod=[&apos;||SUBSTRING(RTRIM(NVL(sqlScriptMod,&apos;  &apos;)),1,debugPrintSize)||&apos;]&apos;);
							end if;
							if (sqlScriptMod is not null) then
								set sqlScript = sqlScriptMod;
							end if;
						end if;
						set pos3 = INSTR(UPPER(sqlScript),&apos; OVER &apos;,pos1end);
						if (pos3 &gt; 0) then
							call /shared/ASAssets/Utilities/string/findOpenClosePair(sqlScript, pos3, encodedComma, &apos;(&apos;,&apos;)&apos;, trimText, leftParenPos, rightParenPos, extractedScript, sqlScriptMod, extractedScriptBefore, extractedScriptAfter);
							if (debug = &apos;Y&apos;) then
								call print(moduleName||&apos; :     &apos;||RTRIM(NVL(analyticalFunction,&apos;  &apos;))||&apos;() OVER(): VALIDATING...pos3:findOpenClosePair sqlScriptMod=[&apos;||SUBSTRING(RTRIM(NVL(sqlScriptMod,&apos;  &apos;)),1,debugPrintSize)||&apos;]&apos;);
							end if;
							if (sqlScriptMod is not null) then
								set sqlScript = sqlScriptMod;
							end if;
						end if;

						-- Find the first occurrence of a comma, &quot;AS&quot; or &quot;FROM&quot; following the analytical function.
						-- The objective is to compare the position of &quot;WITHIN_GROUP&quot;/&quot;OVER&quot; w.r.t. where the comma separates this column. 
						-- If &quot;WITHIN_GROUP&quot;/&quot;OVER&quot; is between pos and pos4 then this is valid.  If &quot;WITHIN_GROUP&quot;/&quot;OVER&quot; is greater than pos4 then this
						--	is not an analytical function.  For example, MIN and MAX is a function with OVER and without OVER.
						set pos4 = INSTR(sqlScript, &apos;,&apos;, pos1end);
						set asPos = INSTR(UPPER(sqlScript),&apos; AS &apos;, pos1end);
						set fromPos = INSTR(UPPER(sqlScript),&apos; FROM &apos;, pos1end);

						-- Determine which one or both of &quot;WITHIN GROUP&quot;/&quot;OVER&quot; exists and which position is greater than the other.
						-- Example 1:
						-- PERCENTILE_DISC(cola,&apos;&apos;,&apos;&apos;) within group (order by colb ASC) OVER (partition by colc, cola, cold) AS AF10     FROM tablename
						-- ^-pos1=1                    ^-pos2=29                        ^-pos3=62                            ^-aspos=99  ^-frompos=112           [pos4=aspos=99]
						-- Example 2:
						-- LISTAGG(cola,&apos;,&apos;) WITHIN GROUP (ORDER BY colb DESC, colc NULLS FIRST) AS      AF11,          RANK()     over (order by MAX(cold) DESCENDING ) AF12   FROM tablename
						-- ^-pos1=1          ^-pos2=19                                           ^-aspos=71  ^pos4=83   ^-pos1=94  ^-pos3=105                                   ^-frompos=150     [pos4=aspos=71]

						-- Calculate the end of this analytical function
						set analyticalFuncEnd = pos4;
						if (pos4 = 0 or (asPos &gt; 0 and asPos &lt; pos4)) then
							set analyticalFuncEnd = asPos;
						end if;
						if (pos4 = 0 or (fromPos &gt; 0 and fromPos &lt; pos4)) then
							set analyticalFuncEnd = fromPos;
						end if;

						-- Calculate whether &quot;WITHIN_GROUP&quot; or &quot;OVER&quot; is greater than the other and less than the end of this analytical function.
						--    The code only needs to know the position of the greater one when both exist so that it can locate the right-most parenthesis &quot;)&quot;.
						-- &quot;WITHIN_GROUP&quot; was found and &quot;OVER&quot; was not found
						if (pos2 &gt; 0 and pos3 = 0 and pos2 &lt; analyticalFuncEnd and pos3 &lt; analyticalFuncEnd) then
							set analyticalFuncPart2 = pos2;
							set analyticalFunctionType = &apos;WITHIN GROUP()&apos;;
						end if;
						-- &quot;WITHIN_GROUP&quot; was not found &quot;OVER&quot; was found
						if (pos2 = 0 and pos3 &gt; 0 and pos2 &lt; analyticalFuncEnd and pos3 &lt; analyticalFuncEnd) then
							set analyticalFuncPart2 = pos3;
							set analyticalFunctionType = &apos;OVER()&apos;;
						end if;
						-- &quot;WITHIN_GROUP&quot; was found and &quot;OVER&quot; was found
						if (pos2 &gt; 0 and pos3 &gt; 0) then
							-- Choose &quot;OVER&quot; postion when both have been found and both are less than the analytical end.  
							--		We just need the greatest position number to start search from.
							if (pos2 &lt; analyticalFuncEnd and pos3 &lt; analyticalFuncEnd) then
								if (pos3 &gt; pos2) then
									set analyticalFuncPart2 = pos3;
									set analyticalFunctionType = &apos;WITHIN GROUP() OVER()&apos;;
								end if;
							end if;
							-- Choose &quot;OVER&quot; postion when both have been found and pos3 is less than the analytical end and pos2 is not.  
							if (pos2 &gt; analyticalFuncEnd and pos3 &lt; analyticalFuncEnd) then
								set analyticalFuncPart2 = pos3;
								set analyticalFunctionType = &apos;WITHIN GROUP() OVER()&apos;;
							end if;
							-- Choose &quot;WITHIN GROUP&quot; postion when both have been found and pos2 is less than the analytical end and pos3 is not.  
							if (pos2 &lt; analyticalFuncEnd and pos3 &gt; analyticalFuncEnd) then
								set analyticalFuncPart2 = pos2;
								set analyticalFunctionType = &apos;WITHIN GROUP() OVER()&apos;;
							end if;
						end if;
						if (debug = &apos;Y&apos;) then
							call print(moduleName||&apos; :     &apos;||RTRIM(NVL(analyticalFunction,&apos;  &apos;))||&apos;() &apos;||analyticalFunctionType||&apos;: VALIDATING...&apos;||
												&apos;  pos1=&apos;||pos1||&apos;  pos2=&apos;||pos2||&apos;  pos3=&apos;||pos3||&apos;  pos4=&apos;||pos4||&apos;  asPos=&apos;||asPos||&apos;  fromPos=&apos;||fromPos||
												&apos;  analyticalFuncPart2=&apos;||analyticalFuncPart2||&apos;  analyticalFuncEnd=&apos;||analyticalFuncEnd);
						end if;

						if (continueAnalyticalLoop1 and pos1 &gt; 0 and analyticalFuncPart2 &gt; pos1 and analyticalFuncPart2 &lt; analyticalFuncEnd) then
							if (debug = &apos;Y&apos;) then
								call print(moduleName||&apos; :     &apos;||RTRIM(NVL(analyticalFunction,&apos;  &apos;))||&apos;() &apos;||analyticalFunctionType||&apos; FOUND...begin sqlScript=[&apos;||SUBSTRING(RTRIM(NVL(sqlScript,&apos;  &apos;)),1,debugPrintSize)||&apos;...&apos;||&apos;]&apos;);
							end if;
							-- Keep track of which analytical functions were found
							if (analyticalFunctions is null) then
								set analyticalFunctions = &apos;&apos;;
								set analyticalFunctions = analyticalFunctions || analyticalFunction;
							else
								-- Only add the analytical function to the list if it does not exist.  Only need 1 occurrence of the function to report on.
								if (INSTR(analyticalFunctions||&apos;,&apos;, analyticalFunction||&apos;,&apos;) = 0) then
									set analyticalFunctions = analyticalFunctions || &apos;,&apos;;
									set analyticalFunctions = analyticalFunctions || analyticalFunction;
								end if;
							end if;

							-- Search through the sql script to find the corresponding right paren ) for the starting left paren (
							-- This assumes there is only a single outer () pair such as P1(  P2 ( ) ).  This pattern is not supported in this context: P1 ( )  P2 ( )
							call /shared/ASAssets/Utilities/string/findOpenClosePair(sqlScript, analyticalFuncPart2, null, &apos;(&apos;,&apos;)&apos;, trimText, leftParenPos, rightParenPos, extractedScript, sqlScriptMod, extractedScriptBefore, extractedScriptAfter);
							set i = rightParenPos + 1;
							set begPos = pos1; -- beginning position is where the analytical function begins
							set endPos = rightParenPos + 1; -- Assume the end position the right paren + 1
							if (debug = &apos;Y&apos;) then
								call print(moduleName||&apos; :     &apos;||RTRIM(NVL(analyticalFunction,&apos;  &apos;))||&apos;() &apos;||analyticalFunctionType||&apos;: FOUND...&apos;||
									&apos;  begPos=&apos;||begPos||&apos;  endPos=&apos;||endPos||&apos;  rightParenPos=&apos;||rightParenPos||
									&apos;  functionEnd:findOpenClosePair sqlScriptMod=[&apos;||SUBSTRING(RTRIM(NVL(sqlScriptMod,&apos;  &apos;)),1,debugPrintSize)||&apos;]&apos;);
							end if;

							-- Look for additional operations following OVER() such as OVER(...) - 1 AS aliasname
							set word = &apos;&apos;;
							set continueAnalyticalLoop2 = true;
							set operationFound = false;
							set operandFound = false;
							set otherText = false;
							set len = LENGTH(sqlScript);
							while (i &lt;= len and continueAnalyticalLoop2) do
								set ch = substring(sqlScript,i,1);
								--call print(&apos;ch=[&apos;||ch||&apos;]&apos;);
								if (ch &lt;&gt; &apos; &apos;) then
									if (ch in (&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;,&apos;%&apos;)) then
										if (not otherText) then
											set operationFound = true;
										end if;
									elseif (ch in (&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;)) then
										if (not otherText) then
											set operandFound = true;
										end if;
									elseif (ch = &apos;,&apos;) then
										set continueAnalyticalLoop2 = false;
									else
										set otherText = true;
										set word = word || ch;
									end if;
									--call print(&apos;otherText=&apos;||cast(otherText as varchar));
									--call print(&apos;operationFound=&apos;||cast(operationFound as varchar));
									--call print(&apos;operandFound=&apos;||cast(operandFound as varchar));
								else
									--call print(&apos;word=&apos;||word);
									if (operationFound and operandFound) then
										set continueAnalyticalLoop2 = false;
										set endPos = i;
									elseif (UPPER(word) = &apos;AS&apos;) then
										set continueAnalyticalLoop2 = false;
									elseif (UPPER(word) = &apos;FROM&apos;) then
										set continueAnalyticalLoop2 = false;
									else
										set word = &apos;&apos;;
									end if;
								end if;
								set i = i + 1;
							end while;

							if (debug = &apos;Y&apos;) then
								call print(moduleName||&apos; :     &apos;||RTRIM(NVL(analyticalFunction,&apos;  &apos;))||&apos;() &apos;||analyticalFunctionType||&apos;:  FOUND...after function operation begPos=&apos;||begPos||&apos;  endPos=&apos;||endPos||&apos;  operationFound=&apos;||cast(operationFound as varchar)||&apos;  operandFound=&apos;||cast(operandFound as varchar)||&apos;  otherText=&apos;||cast(otherText as varchar));
							end if;
							-- Remove all text between left paren ( and right paren ) as it is inconsequential for parsing.
							if (begPos = 1) then
								set sqlScriptMod = &apos;&quot;&apos;||SUBSTRING(sqlScript, begPos, endPos-begPos)||&apos;&quot;&apos;;
								set sqlScript = &apos; &apos;||sqlScriptMod||SUBSTRING(sqlScript,endPos);
								set doEncoding = true;
							else
								set sqlScriptMod = &apos;&quot;&apos;||SUBSTRING(sqlScript, begPos, endPos-begPos)||&apos;&quot;&apos;;
								set sqlScript = &apos; &apos;||SUBSTRING(sqlScript, 1, begPos-1)||sqlScriptMod||SUBSTRING(sqlScript,endPos);
								set doEncoding = true;
							end if;
							if (debug = &apos;Y&apos;) then
								call print(moduleName||&apos; :     &apos;||RTRIM(NVL(analyticalFunction,&apos;  &apos;))||&apos;() &apos;||analyticalFunctionType||&apos;: FOUND...double quoted sqlScriptMod=[&apos;||SUBSTRING(RTRIM(NVL(sqlScriptMod,&apos;  &apos;)),1,debugPrintSize)||&apos;]&apos;);
							end if;
							-- Set the position in which to start searching for the same function name within the existing sqlScriptMod
							set endPos = endPos - 1;
						else
							-- Set the position in which to start searching for the same function name within the existing sqlScriptMod
							set endPos = pos1 + length(analyticalFunction);
						end if;
					else
						set continueAnalyticalLoop1 = false;
					end if;
				end while;
			END IF;
		END WHILE;
		set sqlScript = &apos; &apos;||TRIM(sqlScript);
		if (doEncoding) then
			set actionTaken = true;
			if (INSTR(sqlScript, &apos;&quot;&apos;) &gt; 0) then
				call /shared/ASAssets/Utilities/string/getCodedString(&apos;E&apos;, &apos;D&apos;, encodedSpace, sqlScript, moduleName, debug4, &apos;sqlScript&apos;, sqlScript);
			end if;
		end if;

		-- Determine if an order by is present
		if (INSTR(lower(sqlScript), &apos;order by&apos;) &gt; 0) then
			set containsOrderBy = 1;
		end if;

		if (debug = &apos;Y&apos;) then
			call /shared/ASAssets/Utilities/&quot;time&quot;/getCurrentTimestamp(currentTS);
			set duration = cast(currentTS - sectionStartTime as varchar);
			call print(moduleName||&apos; : duration=&apos;||RPAD(duration,12,&apos; &apos;)||&apos;  actionTaken=&apos;||RPAD(cast(actionTaken as varchar),5,&apos; &apos;)||&apos;  PARSE ANALYTICAL FUNCTIONS: [&apos;||RTRIM(NVL(analyticalFunctions,&apos;NONE&apos;))||&apos;]() final sqlScript=[&apos;||SUBSTRING(RTRIM(NVL(sqlScript,&apos;  &apos;)),1,debugPrintSize)||&apos;...&apos;||&apos;]&apos;);
		end if;

END</attribute>
  <attribute name="creationDate" type="LONG">1549320149243</attribute>
  <attribute name="creatorUserDomain" type="STRING">composite</attribute>
  <attribute name="creatorUserId" type="INTEGER">-1973</attribute>
  <attribute name="creatorUserName" type="STRING">admin</attribute>
  <attribute name="explicitly.designed" type="BOOLEAN">false</attribute>
  <attribute name="lastModifiedDate" type="LONG">1564694132867</attribute>
  <attribute name="lastModifiedUserDomain" type="STRING">composite</attribute>
  <attribute name="lastModifiedUserId" type="INTEGER">-1973</attribute>
  <attribute name="lastModifiedUserName" type="STRING">admin</attribute>
  <attribute name="model" type="NULL"/>
  <attribute name="native_only" type="STRING">false</attribute>
  <attribute name="references" type="MAP">
    <item>
      <key type="STRING">14/232</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/222</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">13/298</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/376</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">12/188</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/389</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/326</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/305</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">13/207</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">9/419</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
  </attribute>
  <attribute name="resourceModifiedDateOnSourceCISSite" type="LONG">1549320149243</attribute>
</metadata>