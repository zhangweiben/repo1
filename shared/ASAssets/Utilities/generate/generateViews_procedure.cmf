<?xml version="1.1" encoding="UTF-8"?>
<!-- salt:44831da2-fa57-48b1-b3e8-4297d727cb06 -->
<metadata name="generateViews" path="/shared/ASAssets/Utilities/generate/generateViews" type="PROCEDURE" subtype="SQL_SCRIPT_PROCEDURE" changeToken="0">
  <annotation>generateViews:

	This script is used to provide a framework for introspection of a relational datasource and generating views to the various
		Data Abstraction Best Practices layers. It provides a simple view generation into the four main layers described by the 
		Data Abstraction Best Practices.  This procedure copies privileges from the parent folder so it is important that 
		proper privileges be assigned ahead of time on the project level folders and recursively pushed down to the layer folders.
		This script will also copy both table and column annotations if they exist at the data source level.  This script will copy
		SQL indexes and foreign keys from the data source to the layers.  The published layer will inherit indexes and foreign keys
		directly from the view/table it was published from.  Published views will have their own annotation but they will inherit
		column annotations from the view they were published from.  The physical, metadata layer containing the datasource is
		mandatory as is the published database layer.  The other three layers are optional and may be included or bypassed based
		on the presence or absence of folder information.  The folder naming conventions are guidelines put forth according to the 
		Data Abstraction Best Practices.  However, the invoker has full flexibility to name the folders whatever they wish since
		all information is passed into this procedure regarding folder path names. 

	A key differentiator between this procedure and the open source project &quot;ASAssets Data Abstraction Best Practices&quot; is that
		this procedure does not provide the ability to rename logical table and column names using a spreadsheet.  Additionally,
		there are several advanced generation capabilities that are not implemented in this procedure including:
			generate/ignore CASE rules, generate/ignore ALIAS rule lookup, generate/ignore CAST statements, and 
			generate/ignore unsupported columns of type OTHER

	The text below describes the Data Abstraction Best Practices folder structure.  Each layer path becomes an input parameter
		for this procedure.

		Published
			/services/databases/Published_Database/[Catalog]/Schema - mandatory
		Application
			/Application/Views/folder 								- optional layer generation [parameter null if not to be generated]
		Business
			/Business/Logical/folder 								- optional layer generation [parameter null if not to be generated]
		Physical
			/Physical/Formatting/folder 							- optional layer generation [parameter null if not to be generated]
			/Physical/Metadata/[catalog]/schema 					- mandatory

	The top [published] and bottom [metadata] layers are mandatory.  The middle layers are optional and the input can be left null
		to indicate that no generation is required in those layers.  Below is a representation of the Data Abstraction Layers and
		how the input variables map to those layers.

					/services/databases
						/TEST							&lt;-- exists	----^
							/CAT1						&lt;-- create	----^
								/SCH1					&lt;-- create	----^ = publishedDBLayerPath
									/V_T1				&lt;-- create	----^
					/shared												|
						/TEST											|
							/Application								|
								/Views/SCH1				&lt;-- create		^ = applicationLayerPath
											/T1			&lt;-- create		|
							/Business									|
								/Logical/SCH1			&lt;-- create		^ = businessLayerPath
											/T1			&lt;-- create		|
							/Physical									|
								/Formatting/SCH1		&lt;-- create		^ = formattingLayerPath
												/T1		&lt;-- create		|
								/Metadata/Oracle/DS1					| = datasourcePath
												  /SCH1	&lt;-- exists      | = [Schema Path] and just the schemaName
													/T1	&lt;-- exists     -| [Table exists]
													/T2 

	Input:
		IN  datasourcePath 					VARCHAR(4096),	-- mandatory.   Full path to datasource
		IN  	catalogName 				VARCHAR,		-- optional (null) - Database catalog Name if applicable
		IN  	schemaName 					VARCHAR,		-- mandatory.  Database schema name
		IN  	schemaTablePatterns			VARCHAR(4096),	-- comma separated list of patterns such as D%, E%, F%.    Introspect all new tables starting with D, E and F
		IN  	tableNames 					LONGVARCHAR,	-- optional.  NULL=no specified table list OR one or more separated tables to introspect.
															-- 		There cannot be any spaces between the separator and the table name.
															--		When NULL, all tables for the schema are introspected.
		IN      schemaProcedurePatterns		VARCHAR(4096),	-- comma separated list of patterns such as D%, E%, F%.    Introspect all new procedures starting with D, E and F.
		IN      procedureNames 				LONGVARCHAR,	-- NULL=no specified procedure list OR 1 or more separated procedures to introspect.
															-- 		There cannot be any spaces between the separator and the procedure name.
															--		When NULL, all procedures are introspected.
		IN		separator					VARCHAR,		-- Default=,  The separator used to separate lists for the input parameters: tableNames and procedureNames
															--	The separator value should not exist within the table or procedure names.
		IN	formattingLayerPath				LONGVARCHAR,	-- Path to target Formatting layer views.  Missing folders are automatically created.
		IN	businessLayerPath				LONGVARCHAR,	-- Path to target Business layer views.  Missing folders are automatically created.
		IN	applicationLayerPath			LONGVARCHAR,	-- Path to target Application layer views.  Missing folders are automatically created.
		IN	publishedDBLayerPath			LONGVARCHAR,	-- Path to target Published Database Schema layer views.  Datasource and schema &quot;must&quot; exist already
		IN  prefix 							VARCHAR(255),	-- prefix for views.  It is recommended that no prefix be added even though the option exists.  Example: V_
		IN  overwrite						SMALLINT,		-- 1=overwrite existing views, 0=do not overwrite existing views (throws exception if views exist)
		IN  copyAnnotation					SMALLINT,		-- 1=copy table and column annotations. 0=do not copy
		IN  copySqlIndexes					SMALLINT,		-- 1=copy SQL indexes from source to target.  0=do not copy 
		IN  copyForeignKeys					SMALLINT,		-- 1=copy foreign keys from source to target.  0=do not copy
		IN  debug							CHAR(1),		-- Y=debug on, N=debug off, null=defaultValues.EnableDebugging1

	Output:
		OUT errStatus 						VARCHAR,		-- SUCCESS or FAILED
		OUT errMessage 						LONGVARCHAR,	-- Error message if errStatus=FAILED, otherwise null
		OUT introspectionResult 			LONGVARCHAR		-- A line (CHR(10)) delimited string of results.  Use introspectResourcesResultCursor() to  return a cursor.
		OUT dataSourceType					VARCHAR,		-- The type of data source that was introspected.
		OUT dataSourceSubtype				VARCHAR,		-- The subtype of data source that was introspected.
		OUT numResourcesIntrospectAdd		INTEGER,		-- Number of resources added during introspection.  Includes catalogs and schemas in the count.
		OUT numTablesIntrospectAdd			INTEGER,		-- Number of tables added during introspection.  Only tables are counted.
		OUT tablesIntrospectAdd				LONGVARCHAR,	-- List of tables added during introspection.  Excludes catalogs and schemas.
		OUT numResourcesIntrospectSkip		INTEGER,		-- Number of resources skipped during introspection.  Includes catalogs and schemas in the count.
		OUT numTablesIntrospectSkip			INTEGER,		-- Number of tables skipped during introspection.  Only tables are counted.
		OUT tablesIntrospectSkip			LONGVARCHAR,	-- List of tables skipped during introspection.  Excludes catalogs and schemas.
		OUT generatedViewsCursor			PIPE (			-- A cursor of results for each row created or updated			
			actionType						VARCHAR,		-- The action taken for this resource:  CREATED, OVERWRITTEN, SKIPPED [EXISTS].
			layerType						VARCHAR,		-- The layer type that the view is being generated in:  METADATA, FORMATTING, BUSINESS, APPLICATION, PUBLISHED.
			resName							VARCHAR,		-- The name of the resource.
			resPath							LONGVARCHAR,	-- The full path to the resource.
			resType							VARCHAR,		-- The type of the resource.
			subtype							VARCHAR,		-- The subtype of the resource.
			parentLineageLayerType			VARCHAR,		-- The layer type of the parent resource according to the lineage.
			parentLineagePath				LONGVARCHAR,	-- The full path of the parent resource according to the lineage.
			metadataLineageName				LONGVARCHAR,	-- Placeholder for generateViews - always null.
			metadataLineagePath				LONGVARCHAR		-- Placeholder for generateViews - always null.
		)

	Release:	Modified Date:	Modified By:		DV Version:		Reason:
	2018.100	01/10/2018		Mike Tinius			7.0.5			created new

	(c) 2017 TIBCO Software Inc.  All rights reserved.
	
	Except as specified below, this software is licensed pursuant to the Eclipse Public License v. 1.0.
	The details can be found in the file LICENSE.
	
	The following proprietary files are included as a convenience, and may not be used except pursuant
	to valid license to Composite Information Server or TIBCOÂ® Data Virtualization Server:
	csadmin-XXXX.jar, csarchive-XXXX.jar, csbase-XXXX.jar, csclient-XXXX.jar, cscommon-XXXX.jar,
	csext-XXXX.jar, csjdbc-XXXX.jar, csserverutil-XXXX.jar, csserver-XXXX.jar, cswebapi-XXXX.jar,
	and customproc-XXXX.jar (where -XXXX is an optional version number).  Any included third party files
	are licensed under the terms contained in their own accompanying LICENSE files, generally named .LICENSE.txt.
	
	This software is licensed AS-IS. Support for this software is not covered by standard maintenance agreements with TIBCO.
	If you would like to obtain assistance with this software, such assistance may be obtained through a separate paid consulting
	agreement with TIBCO.</annotation>
  <parameters>
    <parameter name="datasourcePath" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="catalogName" direction="IN" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="schemaName" direction="IN" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="schemaTablePatterns" direction="IN" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="4096"/>
    </parameter>
    <parameter name="tableNames" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="schemaProcedurePatterns" direction="IN" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="4096"/>
    </parameter>
    <parameter name="procedureNames" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="separator" direction="IN" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="formattingLayerPath" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="businessLayerPath" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="applicationLayerPath" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="publishedDBLayerPath" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="prefix" direction="IN" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="overwrite" direction="IN" nullable="true">
      <datatype name="SMALLINT" type="INTEGER" minValue="-32768" maxValue="32767"/>
    </parameter>
    <parameter name="copyAnnotation" direction="IN" nullable="true">
      <datatype name="SMALLINT" type="INTEGER" minValue="-32768" maxValue="32767"/>
    </parameter>
    <parameter name="copySqlIndexes" direction="IN" nullable="true">
      <datatype name="SMALLINT" type="INTEGER" minValue="-32768" maxValue="32767"/>
    </parameter>
    <parameter name="copyForeignKeys" direction="IN" nullable="true">
      <datatype name="SMALLINT" type="INTEGER" minValue="-32768" maxValue="32767"/>
    </parameter>
    <parameter name="inDebug" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="errStatus" direction="OUT" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="errMessage" direction="OUT" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="introspectionResult" direction="OUT" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="dataSourceType" direction="OUT" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="dataSourceSubtype" direction="OUT" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="numResourcesIntrospectAdd" direction="OUT" nullable="true">
      <datatype name="INTEGER" type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
    </parameter>
    <parameter name="numTablesIntrospectAdd" direction="OUT" nullable="true">
      <datatype name="INTEGER" type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
    </parameter>
    <parameter name="tablesIntrospectAdd" direction="OUT" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="numResourcesIntrospectSkip" direction="OUT" nullable="true">
      <datatype name="INTEGER" type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
    </parameter>
    <parameter name="numTablesIntrospectSkip" direction="OUT" nullable="true">
      <datatype name="INTEGER" type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
    </parameter>
    <parameter name="tablesIntrospectSkip" direction="OUT" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="generatedViewsCursor" direction="OUT" nullable="true">
      <datatype name="generatedViewsCursor" type="TABLE" refId="1">
        <element name="actionType">
          <datatype name="VARCHAR" type="STRING" maxLength="255"/>
        </element>
        <element name="layerType">
          <datatype name="VARCHAR" type="STRING" maxLength="255"/>
        </element>
        <element name="resName">
          <datatype name="VARCHAR" type="STRING" maxLength="255"/>
        </element>
        <element name="resPath">
          <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
        </element>
        <element name="resType">
          <datatype name="VARCHAR" type="STRING" maxLength="255"/>
        </element>
        <element name="subtype">
          <datatype name="VARCHAR" type="STRING" maxLength="255"/>
        </element>
        <element name="parentLineageLayerType">
          <datatype name="VARCHAR" type="STRING" maxLength="255"/>
        </element>
        <element name="parentLineagePath">
          <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
        </element>
        <element name="metadataLineageName">
          <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
        </element>
        <element name="metadataLineagePath">
          <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
        </element>
      </datatype>
    </parameter>
  </parameters>
  <security>
    <owner user="admin" domain="composite"/>
    <privilege group="all" domain="composite" privileges="READ"/>
  </security>
  <dependency target="/lib/debug/Print" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="textToPrint" direction="IN">
        <datatype referenceDefinitionSet="/lib/util/System" referenceType="Text" type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/services/databases/system/DUAL" type="TABLE">
    <datatype type="TABLE" refId="1">
      <element name="DUMMY">
        <datatype type="STRING" minLength="1" maxLength="1"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/generate/helpers/createResourceProcess" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="parentLayerType" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="layerType" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="sourcePathIn" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="sourceType" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="targetPathIn" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="tableNames" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="separator" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="tablePrefix" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="tableQualifier" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="overwrite" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="copyAnnotation" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="copySqlIndexes" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="copyForeignKeys" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="inDebug" direction="IN">
        <datatype type="STRING" minLength="1" maxLength="1"/>
      </element>
      <element name="numCreated" direction="OUT">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
      <element name="numUpdated" direction="OUT">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
      <element name="result" direction="OUT">
        <datatype type="TABLE" refId="2">
          <element name="actionType">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="layerType">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="resName">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="resPath">
            <datatype type="STRING" maxLength="2147483647"/>
          </element>
          <element name="resType">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="subtype">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="parentLineageLayerType">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="parentLineagePath">
            <datatype type="STRING" maxLength="2147483647"/>
          </element>
          <element name="metadataLineageName">
            <datatype type="STRING" maxLength="2147483647"/>
          </element>
          <element name="metadataLineagePath">
            <datatype type="STRING" maxLength="2147483647"/>
          </element>
        </datatype>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/repository/introspectResources" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="dsPath" direction="IN">
        <datatype referenceDefinitionSet="/lib/resource/ResourceDefs" referenceType="ResourcePath" type="STRING" maxLength="4096"/>
      </element>
      <element name="catalogName" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="schemaNames" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="schemaTablePatterns" direction="IN">
        <datatype type="STRING" maxLength="4096"/>
      </element>
      <element name="tableNames" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="schemaProcedurePatterns" direction="IN">
        <datatype type="STRING" maxLength="4096"/>
      </element>
      <element name="procedureNames" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="separator" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="inDebug" direction="IN">
        <datatype type="STRING" minLength="1" maxLength="1"/>
      </element>
      <element name="errStatus" direction="OUT">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="errMessage" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="introspectionResult" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="dataSourceType" direction="OUT">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="dataSourceSubtype" direction="OUT">
        <datatype type="STRING" maxLength="255"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/repository/introspectResourcesResultCursor" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="introspectionResult" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="result" direction="OUT">
        <datatype type="TABLE" refId="2">
          <element name="status">
            <datatype type="STRING" maxLength="32768"/>
          </element>
          <element name="introspectorVersion">
            <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
          </element>
          <element name="startTime">
            <datatype type="DATETIME"/>
          </element>
          <element name="endTime">
            <datatype type="DATETIME"/>
          </element>
          <element name="addedCount">
            <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
          </element>
          <element name="removedCount">
            <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
          </element>
          <element name="updatedCount">
            <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
          </element>
          <element name="skippedCount">
            <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
          </element>
          <element name="totalCompletedCount">
            <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
          </element>
          <element name="toBeAddedCount">
            <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
          </element>
          <element name="toBeRemovedCount">
            <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
          </element>
          <element name="toBeUpdatedCount">
            <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
          </element>
          <element name="totalToBeCompletedCount">
            <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
          </element>
          <element name="warningCount">
            <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
          </element>
          <element name="errorCount">
            <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
          </element>
          <element name="path">
            <datatype type="STRING" maxLength="4096"/>
          </element>
          <element name="type">
            <datatype type="STRING" maxLength="40"/>
          </element>
          <element name="subtype">
            <datatype type="STRING" maxLength="40"/>
          </element>
          <element name="action">
            <datatype type="STRING" maxLength="32768"/>
          </element>
          <element name="durationMs">
            <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
          </element>
          <element name="entryStatus">
            <datatype type="STRING" maxLength="32768"/>
          </element>
          <element name="code">
            <datatype type="STRING" maxLength="32768"/>
          </element>
          <element name="name">
            <datatype type="STRING" maxLength="32768"/>
          </element>
          <element name="message">
            <datatype type="STRING" maxLength="2147483647"/>
          </element>
          <element name="detail">
            <datatype type="STRING" maxLength="32768"/>
          </element>
          <element name="severity">
            <datatype type="STRING" maxLength="32768"/>
          </element>
        </datatype>
      </element>
    </datatype>
  </dependency>
  <attribute name="Script" type="STRING">/* 
	generateViews:

	This script is used to provide a framework for introspection of a relational datasource and generating views to the various
		Data Abstraction Best Practices layers. It provides a simple view generation into the four main layers described by the 
		Data Abstraction Best Practices.  This procedure copies privileges from the parent folder so it is important that 
		proper privileges be assigned ahead of time on the project level folders and recursively pushed down to the layer folders.
		This script will also copy both table and column annotations if they exist at the data source level.  This script will copy
		SQL indexes and foreign keys from the data source to the layers.  The published layer will inherit indexes and foreign keys
		directly from the view/table it was published from.  Published views will have their own annotation but they will inherit
		column annotations from the view they were published from.  The physical, metadata layer containing the datasource is
		mandatory as is the published database layer.  The other three layers are optional and may be included or bypassed based
		on the presence or absence of folder information.  The folder naming conventions are guidelines put forth according to the 
		Data Abstraction Best Practices.  However, the invoker has full flexibility to name the folders whatever they wish since
		all information is passed into this procedure regarding folder path names. 

	A key differentiator between this procedure and the open source project &quot;ASAssets Data Abstraction Best Practices&quot; is that
		this procedure does not provide the ability to rename logical table and column names using a spreadsheet.  Additionally,
		there are several advanced generation capabilities that are not implemented in this procedure including:
			generate/ignore CASE rules, generate/ignore ALIAS rule lookup, generate/ignore CAST statements, and 
			generate/ignore unsupported columns of type OTHER

	The text below describes the Data Abstraction Best Practices folder structure.  Each layer path becomes an input parameter
		for this procedure.

		Published
			/services/databases/Published_Database/[Catalog]/Schema - mandatory
		Application
			/Application/Views/folder 								- optional layer generation [parameter null if not to be generated]
		Business
			/Business/Logical/folder 								- optional layer generation [parameter null if not to be generated]
		Physical
			/Physical/Formatting/folder 							- optional layer generation [parameter null if not to be generated]
			/Physical/Metadata/[catalog]/schema 					- mandatory

	The top [published] and bottom [metadata] layers are mandatory.  The middle layers are optional and the input can be left null
		to indicate that no generation is required in those layers.  Below is a representation of the Data Abstraction Layers and
		how the input variables map to those layers.

					/services/databases
						/TEST							&lt;-- exists	----^
							/CAT1						&lt;-- create	----^
								/SCH1					&lt;-- create	----^ = publishedDBLayerPath
									/V_T1				&lt;-- create	----^
					/shared												|
						/TEST											|
							/Application								|
								/Views/SCH1				&lt;-- create		^ = applicationLayerPath
											/T1			&lt;-- create		|
							/Business									|
								/Logical/SCH1			&lt;-- create		^ = businessLayerPath
											/T1			&lt;-- create		|
							/Physical									|
								/Formatting/SCH1		&lt;-- create		^ = formattingLayerPath
												/T1		&lt;-- create		|
								/Metadata/Oracle/DS1					| = datasourcePath
												  /SCH1	&lt;-- exists      | = [Schema Path] and just the schemaName
													/T1	&lt;-- exists     -| [Table exists]
													/T2 

	Input:
		IN  datasourcePath 					VARCHAR(4096),	-- mandatory.   Full path to datasource
		IN  	catalogName 				VARCHAR,		-- optional (null) - Database catalog Name if applicable
		IN  	schemaName 					VARCHAR,		-- mandatory.  Database schema name
		IN  	schemaTablePatterns			VARCHAR(4096),	-- comma separated list of patterns such as D%, E%, F%.    Introspect all new tables starting with D, E and F
		IN  	tableNames 					LONGVARCHAR,	-- optional.  NULL=no specified table list OR one or more separated tables to introspect.
															-- 		There cannot be any spaces between the separator and the table name.
															--		When NULL, all tables for the schema are introspected.
		IN      schemaProcedurePatterns		VARCHAR(4096),	-- comma separated list of patterns such as D%, E%, F%.    Introspect all new procedures starting with D, E and F.
		IN      procedureNames 				LONGVARCHAR,	-- NULL=no specified procedure list OR 1 or more separated procedures to introspect.
															-- 		There cannot be any spaces between the separator and the procedure name.
															--		When NULL, all procedures are introspected.
		IN		separator					VARCHAR,		-- Default=,  The separator used to separate lists for the input parameters: tableNames and procedureNames
															--	The separator value should not exist within the table or procedure names.
		IN	formattingLayerPath				LONGVARCHAR,	-- Path to target Formatting layer views.  Missing folders are automatically created.
		IN	businessLayerPath				LONGVARCHAR,	-- Path to target Business layer views.  Missing folders are automatically created.
		IN	applicationLayerPath			LONGVARCHAR,	-- Path to target Application layer views.  Missing folders are automatically created.
		IN	publishedDBLayerPath			LONGVARCHAR,	-- Path to target Published Database Schema layer views.  Datasource and schema &quot;must&quot; exist already
		IN  prefix 							VARCHAR(255),	-- prefix for views.  It is recommended that no prefix be added even though the option exists.  Example: V_
		IN  overwrite						SMALLINT,		-- 1=overwrite existing views, 0=do not overwrite existing views (throws exception if views exist)
		IN  copyAnnotation					SMALLINT,		-- 1=copy table and column annotations. 0=do not copy
		IN  copySqlIndexes					SMALLINT,		-- 1=copy SQL indexes from source to target.  0=do not copy 
		IN  copyForeignKeys					SMALLINT,		-- 1=copy foreign keys from source to target.  0=do not copy
		IN  debug							CHAR(1),		-- Y=debug on, N=debug off, null=defaultValues.EnableDebugging1

	Output:
		OUT errStatus 						VARCHAR,		-- SUCCESS or FAILED
		OUT errMessage 						LONGVARCHAR,	-- Error message if errStatus=FAILED, otherwise null
		OUT introspectionResult 			LONGVARCHAR		-- A line (CHR(10)) delimited string of results.  Use introspectResourcesResultCursor() to  return a cursor.
		OUT dataSourceType					VARCHAR,		-- The type of data source that was introspected.
		OUT dataSourceSubtype				VARCHAR,		-- The subtype of data source that was introspected.
		OUT numResourcesIntrospectAdd		INTEGER,		-- Number of resources added during introspection.  Includes catalogs and schemas in the count.
		OUT numTablesIntrospectAdd			INTEGER,		-- Number of tables added during introspection.  Only tables are counted.
		OUT tablesIntrospectAdd				LONGVARCHAR,	-- List of tables added during introspection.  Excludes catalogs and schemas.
		OUT numResourcesIntrospectSkip		INTEGER,		-- Number of resources skipped during introspection.  Includes catalogs and schemas in the count.
		OUT numTablesIntrospectSkip			INTEGER,		-- Number of tables skipped during introspection.  Only tables are counted.
		OUT tablesIntrospectSkip			LONGVARCHAR,	-- List of tables skipped during introspection.  Excludes catalogs and schemas.
		OUT generatedViewsCursor			PIPE (			-- A cursor of results for each row created or updated			
			actionType						VARCHAR,		-- The action taken for this resource:  CREATED, OVERWRITTEN, SKIPPED [EXISTS].
			layerType						VARCHAR,		-- The layer type that the view is being generated in:  METADATA, FORMATTING, BUSINESS, APPLICATION, PUBLISHED.
			resName							VARCHAR,		-- The name of the resource.
			resPath							LONGVARCHAR,	-- The full path to the resource.
			resType							VARCHAR,		-- The type of the resource.
			subtype							VARCHAR,		-- The subtype of the resource.
			parentLineageLayerType			VARCHAR,		-- The layer type of the parent resource according to the lineage.
			parentLineagePath				LONGVARCHAR,	-- The full path of the parent resource according to the lineage.
			metadataLineageName				LONGVARCHAR,	-- Placeholder for generateViews - always null.
			metadataLineagePath				LONGVARCHAR		-- Placeholder for generateViews - always null.
		)

	Release:	Modified Date:	Modified By:		DV Version:		Reason:
	2018.100	01/10/2018		Mike Tinius			7.0.5			created new

	(c) 2017 TIBCO Software Inc.  All rights reserved.
	
	Except as specified below, this software is licensed pursuant to the Eclipse Public License v. 1.0.
	The details can be found in the file LICENSE.
	
	The following proprietary files are included as a convenience, and may not be used except pursuant
	to valid license to Composite Information Server or TIBCOÂ® Data Virtualization Server:
	csadmin-XXXX.jar, csarchive-XXXX.jar, csbase-XXXX.jar, csclient-XXXX.jar, cscommon-XXXX.jar,
	csext-XXXX.jar, csjdbc-XXXX.jar, csserverutil-XXXX.jar, csserver-XXXX.jar, cswebapi-XXXX.jar,
	and customproc-XXXX.jar (where -XXXX is an optional version number).  Any included third party files
	are licensed under the terms contained in their own accompanying LICENSE files, generally named .LICENSE.txt.
	
	This software is licensed AS-IS. Support for this software is not covered by standard maintenance agreements with TIBCO.
	If you would like to obtain assistance with this software, such assistance may be obtained through a separate paid consulting
	agreement with TIBCO.

*/
PROCEDURE generateViews(
	IN  datasourcePath 					LONGVARCHAR,	-- mandatory.   Full path to datasource
	IN  	catalogName 				VARCHAR,		-- optional (null) - Database catalog Name if applicable
	IN  	schemaName 					VARCHAR,		-- mandatory - Database schema name.  Overrides the schema pattern.  When schemaPatterns is null the schemaName must be provided.
	IN  	schemaTablePatterns			VARCHAR(4096),	-- optional (null).  Comma separated list of patterns such as D%, E%, F%.    Introspect all tables starting with D, E and F.
	IN      tableNames 					LONGVARCHAR,	-- optional.  NULL=no specified table list OR one or more separated tables to introspect.  When NULL, all tables for the schema are introspected.
														-- 		There cannot be any spaces between the separator and the table name.
														--		When NULL, all tables for the schema are introspected.
	IN      schemaProcedurePatterns		VARCHAR(4096),	-- comma separated list of patterns such as D%, E%, F%.    Introspect all new procedures starting with D, E and F.
	IN      procedureNames 				LONGVARCHAR,	-- NULL=no specified procedure list OR 1 or more separated procedures to introspect.  When NULL, all procedures are introspected.
														-- 		There cannot be any spaces between the separator and the procedure name.
														--		When NULL, all procedures are introspected.
	IN		separator					VARCHAR,		-- Default=,  The separator used to separate lists for the input parameters: tableNames and procedureNames
														--		The separator value should not exist within the table or procedure names.
	IN	formattingLayerPath				LONGVARCHAR,	-- Path to target Formatting layer views.  Missing folders are automatically created.
	IN	businessLayerPath				LONGVARCHAR,	-- Path to target Business layer views.  Missing folders are automatically created.
	IN	applicationLayerPath			LONGVARCHAR,	-- Path to target Application layer views.  Missing folders are automatically created.
	IN	publishedDBLayerPath			LONGVARCHAR,	-- Path to target Published Database Schema layer views.  Datasource and schema &quot;must&quot; exist already
	IN  prefix 							VARCHAR(255),	-- prefix for views.  It is recommended that no prefix be added even though the option exists.  Example: V_
	IN  overwrite						SMALLINT,		-- 1=overwrite existing views, 0=do not overwrite existing views (throws exception if views exist)
	IN  copyAnnotation					SMALLINT,		-- 1=copy table and column annotations. 0=do not copy
	IN  copySqlIndexes					SMALLINT,		-- 1=copy SQL indexes from source to target.  0=do not copy 
	IN  copyForeignKeys					SMALLINT,		-- 1=copy foreign keys from source to target.  0=do not copy
	IN  inDebug							CHAR(1),		-- Y=debug on, N=debug off, null=N

	OUT errStatus 						VARCHAR,		-- SUCCESS OR FAILED
	OUT errMessage 						LONGVARCHAR,	-- Error message if errStatus=FAILED
	OUT introspectionResult 			LONGVARCHAR,	-- A line (CHR(10)) delimited string of results.  Use introspectResourcesResultCursor() to  return a cursor.
	OUT dataSourceType					VARCHAR,		-- The type of data source that was introspected.
	OUT dataSourceSubtype 				VARCHAR,		-- The subtype of data source that was introspected.
	OUT numResourcesIntrospectAdd		INTEGER,		-- Number of resources added during introspection.  Includes catalogs and schemas in the count.
	OUT numTablesIntrospectAdd			INTEGER,		-- Number of tables added during introspection.  Only tables are counted.
	OUT tablesIntrospectAdd				LONGVARCHAR,	-- List of tables added during introspection.  Excludes catalogs and schemas.
	OUT numResourcesIntrospectSkip		INTEGER,		-- Number of resources skipped during introspection.  Includes catalogs and schemas in the count.
	OUT numTablesIntrospectSkip			INTEGER,		-- Number of tables skipped during introspection.  Only tables are counted.
	OUT tablesIntrospectSkip			LONGVARCHAR,	-- List of tables skipped during introspection.  Excludes catalogs and schemas.
	OUT generatedViewsCursor			PIPE (			-- A cursor of results for each row created or updated			
		actionType						VARCHAR,		-- The action taken for this resource:  CREATED, OVERWRITTEN, SKIPPED [EXISTS].
		layerType						VARCHAR,		-- The layer type that the view is being generated in:  METADATA, FORMATTING, BUSINESS, APPLICATION, PUBLISHED.
		resName							VARCHAR,		-- The name of the resource.
		resPath							LONGVARCHAR,	-- The full path to the resource.
		resType							VARCHAR,		-- The type of the resource.
		subtype							VARCHAR,		-- The subtype of the resource.
		parentLineageLayerType			VARCHAR,		-- The layer type of the parent resource according to the lineage.
		parentLineagePath				LONGVARCHAR,	-- The full path of the parent resource according to the lineage.
		metadataLineageName				LONGVARCHAR,	-- Placeholder for generateViews - always null.
		metadataLineagePath				LONGVARCHAR		-- Placeholder for generateViews - always null.
	)
)
BEGIN
	DECLARE moduleName			VARCHAR DEFAULT &apos;generateViews&apos;;
	DECLARE debug				CHAR(1) DEFAULT NVL(UPPER(inDebug), &apos;N&apos;);
	DECLARE sep					VARCHAR DEFAULT NVL(separator, &apos;,&apos;);
	DECLARE datasourcePathMod	LONGVARCHAR DEFAULT TRIM(datasourcePath);
	DECLARE Tab_Prefix 			VARCHAR(255) DEFAULT prefix;
	DECLARE Tab_Qualifier		VARCHAR;
	DECLARE Table_Name1			LONGVARCHAR;
	DECLARE Table_Name2			LONGVARCHAR;
	DECLARE Table_Names			LONGVARCHAR DEFAULT null;
	DECLARE Table_Names1		LONGVARCHAR DEFAULT &apos;&apos;;
	DECLARE Table_Names2		LONGVARCHAR DEFAULT &apos;&apos;;
	DECLARE beginProc			TIMESTAMP DEFAULT CURRENT_TIMESTAMP;
	DECLARE beginTS				TIMESTAMP;
	DECLARE duration			INTERVAL DAY TO SECOND;
	DECLARE numCreated			INTEGER DEFAULT 0;
	DECLARE numUpdated			INTEGER DEFAULT 0;
	DECLARE message				LONGVARCHAR;
	DECLARE sourcePathTemp		LONGVARCHAR;
	DECLARE sourcePath			LONGVARCHAR;
	DECLARE sourceType			VARCHAR;
	DECLARE containerPath		LONGVARCHAR DEFAULT null;
	DECLARE containerType		VARCHAR DEFAULT null;
	DECLARE prevContainerPath	LONGVARCHAR DEFAULT null;
	DECLARE prevContainerType	VARCHAR DEFAULT null;
	DECLARE targetPath			LONGVARCHAR;
	DECLARE metadataName		VARCHAR;
	DECLARE metadataPath		LONGVARCHAR;
	DECLARE metadataLineage		LONGVARCHAR DEFAULT &apos;&apos;;
	DECLARE i, pos1, pos2, len	INTEGER DEFAULT 0;
	DECLARE containerCount		INTEGER DEFAULT 0;
	DECLARE ex					EXCEPTION;
	DECLARE parentLayerType		VARCHAR;		-- The layer type of the parent path.
	DECLARE layerType			VARCHAR;		-- The layer type of the current path.
	DECLARE TYPE resultType		ROW (			-- A row type to capture results for each row created or updated
		actionType				VARCHAR,		-- The action taken for this resource:  CREATED, OVERWRITTEN, SKIPPED [EXISTS].
		layerType				VARCHAR,		-- The layer type that the view is being generated in:  METADATA, FORMATTING, BUSINESS, APPLICATION, PUBLISHED.
		resName					VARCHAR,		-- The name of the resource.
		resPath					LONGVARCHAR,	-- The full path to the resource.
		resType					VARCHAR,		-- The type of the resource.
		subtype					VARCHAR,		-- The subtype of the resource.
		parentLineageLayerType	VARCHAR,		-- The layer type of the parent resource according to the lineage.
		parentLineagePath		LONGVARCHAR,	-- The full path of the parent resource according to the lineage.
		metadataLineageName		LONGVARCHAR,	-- Placeholder for generateViews - always null.
		metadataLineagePath		LONGVARCHAR		-- Placeholder for generateViews - always null.
	);
	DECLARE resultRec			resultType;
	DECLARE resultCursor		CURSOR resultType;

	-- Remove any white space and / at the end if exists.
	IF (SUBSTRING(datasourcePathMod, LENGTH(datasourcePathMod), 1) = &apos;/&apos;) THEN
		SET datasourcePathMod = SUBSTRING(datasourcePathMod, 1, LENGTH(datasourcePathMod)-1);
	END IF;
	IF (debug = &apos;Y&apos;) THEN
		CALL PRINT (moduleName||&apos; : &apos;||&apos; INPUT:&apos;);
		CALL PRINT (moduleName||&apos; : &apos;||&apos;    datasourcePath=[&apos;||NVL(datasourcePathMod,&apos;null&apos;)||&apos;]&apos;);
		CALL PRINT (moduleName||&apos; : &apos;||&apos;    ____catalogName=[&apos;||NVL(catalogName,&apos;null&apos;)||&apos;]&apos;);
		CALL PRINT (moduleName||&apos; : &apos;||&apos;    ____schemaName=[&apos;||NVL(schemaName,&apos;null&apos;)||&apos;]&apos;);
		CALL PRINT (moduleName||&apos; : &apos;||&apos;    ____schemaTablePatterns=[&apos;||NVL(schemaTablePatterns,&apos;null&apos;)||&apos;]&apos;);
		CALL PRINT (moduleName||&apos; : &apos;||&apos;    ____tableNames=[&apos;||NVL(tableNames,&apos;null&apos;)||&apos;]&apos;);
		CALL PRINT (moduleName||&apos; : &apos;||&apos;    ____schemaProcedurePatterns=[&apos;||NVL(schemaProcedurePatterns,&apos;null&apos;)||&apos;]&apos;);
		CALL PRINT (moduleName||&apos; : &apos;||&apos;    ____procedureNames=[&apos;||NVL(procedureNames,&apos;null&apos;)||&apos;]&apos;);
		CALL PRINT (moduleName||&apos; : &apos;||&apos;    ____separator=[&apos;||NVL(sep,&apos;null&apos;)||&apos;]&apos;);
		CALL PRINT (moduleName||&apos; : &apos;||&apos;    formattingLayerPath=&apos;||NVL(formattingLayerPath,&apos;null&apos;));
		CALL PRINT (moduleName||&apos; : &apos;||&apos;    businessLayerPath=[&apos;||NVL(businessLayerPath,&apos;null&apos;)||&apos;]&apos;);
		CALL PRINT (moduleName||&apos; : &apos;||&apos;    applicationLayerPath=[&apos;||NVL(applicationLayerPath,&apos;null&apos;)||&apos;]&apos;);
		CALL PRINT (moduleName||&apos; : &apos;||&apos;    publishedDBLayerPath=[&apos;||NVL(publishedDBLayerPath,&apos;null&apos;)||&apos;]&apos;);
		CALL PRINT (moduleName||&apos; : &apos;||&apos;    prefix=[&apos;||NVL(prefix,&apos;null&apos;)||&apos;]&apos;);
		CALL PRINT (moduleName||&apos; : &apos;||&apos;    overwrite=&apos;||NVL(CAST(overwrite AS VARCHAR),&apos;null&apos;));
		CALL PRINT (moduleName||&apos; : &apos;||&apos;    copyAnnotation=&apos;||NVL(CAST(copyAnnotation AS VARCHAR),&apos;null&apos;));
		CALL PRINT (moduleName||&apos; : &apos;||&apos;    copySqlIndexes=&apos;||NVL(CAST(copySqlIndexes AS VARCHAR),&apos;null&apos;));
		CALL PRINT (moduleName||&apos; : &apos;||&apos;    copyForeignKeys=&apos;||NVL(CAST(copyForeignKeys AS VARCHAR),&apos;null&apos;));
	END IF;

	-- Set default values
	SET beginTS = CURRENT_TIMESTAMP;
	SET prevContainerPath = datasourcePathMod;	-- Default to the datasource for purposes of comparison.
	SET prevContainerType = &apos;DATA_SOURCE&apos;;	-- Default to the datasource type for purposes of comparison.
	SET numResourcesIntrospectAdd = 0;
	SET numTablesIntrospectAdd = 0;
	SET numResourcesIntrospectSkip = 0;
	SET numTablesIntrospectSkip = 0;
	SET tablesIntrospectAdd = &apos;&apos;;
	SET tablesIntrospectSkip = &apos;&apos;;

	/*
		Generate Physical Metadata Layer
	*/
	IF (debug = &apos;Y&apos;) THEN
		SET message = moduleName||&apos; : &apos;||CAST(beginTS AS VARCHAR)||&apos; BEGIN INTROSPECTION OF MEATADATA SOURCE: &apos;||NVL(datasourcePathMod,&apos;null&apos;);
		CALL print(message);
	END IF;
	BEGIN INDEPENDENT TRANSACTION
		CALL /shared/ASAssets/Utilities/repository/introspectResources(
			datasourcePathMod,			-- mandatory.   Full path to datasource
			catalogName,				-- optional (null) - Database catalog Name if applicable
			schemaName,					-- mandatory - Database schema name.  Overrides the schema pattern.  When schemaPatterns is null the schemaName must be provided.
			schemaTablePatterns,		-- optional (null).  Comma separated list of patterns such as D%, E%, F%.    Introspect all tables starting with D, E and F.
			tableNames,					-- optional.  NULL=no specified table list OR one or more comma separated tables to introspect.  When NULL, all tables for the schema are introspected.
			schemaProcedurePatterns,	-- comma separated list of patterns such as D%, E%, F%.    Introspect all new procedures starting with D, E and F.
			procedureNames, 			-- NULL=no specified procedure list OR 1 or more comma separated procedures to introspect.  When NULL, all procedures are introspected.
			sep,						-- Default=,  The separator used to separate lists for the input parameters: tableNames and procedureNames
			debug,						-- Y=debug on, N=debug off, null=defaultValues.EnableDebugging1
			errStatus,					-- SUCCESS or FAILED
			errMessage,					-- Error message if errStatus=FAILED, otherwise null
			introspectionResult,		-- A line (CHR(10)) delimited string of results.  Use introspectResourcesResultCursor() to  return a cursor.
			dataSourceType,				-- The type of data source that was introspected.
			dataSourceSubtype			-- The subtype of data source that was introspected.
		);
	EXCEPTION
		ELSE
			RAISE ex VALUE CURRENT_EXCEPTION.TRACE;
	END;

		-- Extract the introspection results
		FOR r AS 
			SELECT * FROM (
				SELECT * FROM /shared/ASAssets/Utilities/repository/introspectResourcesResultCursor(introspectionResult)
			) a
			UNION
			-- This row will always occur last and is used to create a dummy row in order to trigger processing of the last row while still inside the for loop
			SELECT null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,&apos;DUMMY_CONTAINER_PATH&apos;,&apos;CONTAINER&apos;,&apos;DUMMY_CONTAINER&apos;,&apos;DUMMY_SKIP&apos;,null,null,null,null,null,null,null
				FROM /services/databases/system/DUAL
		DO
			SET i = i + 1;
			IF (debug = &apos;Y&apos;) THEN
				CALL print( moduleName||&apos; : loop i=&apos;||i||&apos; &quot;path&quot;=&apos;||NVL(r.&quot;path&quot;,&apos;null&apos;)||&apos;  type=&apos;||NVL(r.&quot;type&quot;,&apos;null&apos;)||&apos;  suybtype=&apos;||NVL(r.subtype,&apos;null&apos;));
			END IF;

			--  Begin processing the list of tables whenever a container is encountered that is not a catalog container.  e.g. SCHEMA_CONTAINER, DIRECTORY_CONTAINER
			IF (r.&quot;type&quot; = &apos;CONTAINER&apos; AND r.subtype &lt;&gt; &apos;CATALOG_CONTAINER&apos;) THEN
				SET containerCount = containerCount + 1;
				SET containerPath = r.&quot;path&quot;;
				SET containerType = r.&quot;type&quot;;

				IF (debug = &apos;Y&apos;) THEN
					CALL print( moduleName||&apos; :   containerCount=&apos;||containerCount||&apos;  prevContainerPath=[&apos;||NVL(prevContainerPath,&apos;null&apos;)||&apos;]  containerPath=[&apos;||NVL(containerPath,&apos;null&apos;)||&apos;]&apos;);
					CALL print( moduleName||&apos; :   Table_Names=&apos;||NVL(Table_Names,&apos;null&apos;)||&apos;  Table_Names1=[&apos;||NVL(Table_Names1,&apos;null&apos;)||&apos;]  Table_Names2=[&apos;||NVL(Table_Names2,&apos;null&apos;)||&apos;]&apos;);
				END IF;
				IF (prevContainerPath &lt;&gt; containerPath) THEN
					-- Process the records if it is the last row or the container count is greater than 1 and it is not the last row
					IF (r.subtype = &apos;DUMMY_CONTAINER&apos; OR (containerCount &gt; 1 AND r.subtype &lt;&gt; &apos;DUMMY_CONTAINER&apos;)) THEN
						-- Determine the source type and source path
						CASE
							WHEN dataSourceSubtype = &apos;RELATIONAL_DATA_SOURCE&apos; THEN
								IF (prevContainerPath &lt;&gt; datasourcePathMod) THEN
									SET sourcePath = datasourcePathMod||&apos;/&apos;||prevContainerPath; -- Append the catalog/schema path to the datasource path
									SET sourceType = prevContainerType;	-- A schema folder is of type CONTAINER
								ELSE
									SET sourcePath = datasourcePathMod;
									SET sourceType = &apos;DATA_SOURCE&apos;;	-- A Relational datasource with no schema (e.g. mysql) will not have any underlying folders therefore the datasource is the originating source folder.
								END IF;
								SET Tab_Qualifier = null;
							WHEN dataSourceSubtype = &apos;FILE_DATA_SOURCE&apos; THEN
								SET sourcePath = datasourcePathMod;
								SET sourceType = &apos;DATA_SOURCE&apos;;	-- A CSV datasource has no underlying folders therefore the datasource is the originating source folder.
								SET Tab_Qualifier = null;
							WHEN dataSourceSubtype = &apos;POI_EXCEL_DATA_SOURCE&apos; THEN
								SET sourcePath = datasourcePathMod||&apos;/&apos;||prevContainerPath;
								SET sourceType = prevContainerType;	-- A directory container is of type CONTAINER
								-- For Excel datasources, add the container name with a dash as a qualifier to the sheet name
								SET Tab_Qualifier = prevContainerPath||&apos;-&apos;;
							ELSE	
								SET sourcePath = null;
								SET sourceType = null;
						END CASE;

						-- Process the list of table names
						IF (sourcePath IS NOT NULL AND LENGTH(TRIM(sourcePath)) &gt; 0) THEN
							IF (debug = &apos;Y&apos;) THEN
								call print(moduleName||&apos; : layerType=&apos;||NVL(layerType, &apos;null&apos;)||&apos;  metadataLineage:&apos;||NVL(metadataLineage,&apos;null&apos;));
							END IF;
							/*
								Generate Formatting Layer
							*/
							BEGIN INDEPENDENT TRANSACTION
								SET beginTS = CURRENT_TIMESTAMP;
								SET parentLayerType = layerType;
								SET layerType = &apos;FORMATTING&apos;;

								IF (formattingLayerPath IS NOT NULL AND LENGTH(TRIM(formattingLayerPath)) &gt; 0) then 
									SET targetPath = formattingLayerPath;
									-- Remove any white space and / at the end if exists.
									IF (SUBSTRING(targetPath, LENGTH(targetPath), 1) = &apos;/&apos;) THEN
										SET targetPath = SUBSTRING(targetPath, 1, LENGTH(targetPath)-1);
									END IF;
									IF (debug = &apos;Y&apos;) THEN
										SET message = moduleName||&apos; : &apos;||CAST(beginTS AS VARCHAR)||&apos; BEGIN GENERATE FORMATTING LAYER: &apos;||NVL(targetPath,&apos;null&apos;);
										CALL print(message);
									END IF;
									-- Test for table names usage
									IF (Table_Names IS NULL) THEN
										SET Table_Names = Table_Names1;	-- This contains the original list
									ELSE
										SET Table_Names = Table_Names2;	-- This contains a modified list with prefixes
									END IF;

									-- Create the resources for this layer
									CALL /shared/ASAssets/Utilities/generate/helpers/createResourceProcess(
										parentLayerType, layerType, sourcePath, sourceType, targetPath, Table_Names, sep, 				-- Input params
										Tab_Prefix, Tab_Qualifier, overwrite, copyAnnotation, copySqlIndexes, copyForeignKeys, debug,	-- Input params
										numCreated, numUpdated, resultCursor);															-- Output params
									FOR crp AS resultCursor DO
										SET resultRec = crp;
										-- Keep a running list of the metadata.  Initialize this list with [metadata path==&gt;metadata path]
										-- The first metadata path in the list will be replaced subsequently with the source path until
										-- the published layer points to the metadata path.
										IF (resultRec.parentLineagePath IS NOT NULL) THEN
											SET pos1 = INSTR(metadataLineage, resultRec.parentLineagePath||&apos;==&gt;&apos;);
											SET len = LENGTH(resultRec.parentLineagePath);
											SET pos2 = INSTR(metadataLineage, &apos;]&apos;, pos1+len+3);
											IF (pos1 &gt; 0) THEN
												-- Extract the corresponding metadata path for this resource
												SET resultRec.metadataLineagePath = SUBSTRING(metadataLineage, pos1+len+3, pos2-(pos1+len+3));
												-- Extract the resource name
												SET pos2 = INSTR(resultRec.metadataLineagePath, &apos;/&apos;, -1, 1);
												SET resultRec.metadataLineageName = SUBSTRING(resultRec.metadataLineagePath, pos2+1);
												-- Rewrite the source path with the current resource path
												SET metadataLineage = SUBSTRING(metadataLineage, 1, pos1-1) || resultRec.resPath || SUBSTRING(metadataLineage, pos1+len);
											END IF;
										END IF;
										-- Insert the record
										INSERT INTO generatedViewsCursor VALUES (resultRec);
									END FOR;
									SET sourcePath = targetPath;
									SET sourceType = &apos;CONTAINER&apos;;
									SET Tab_Prefix = null;
									SET Tab_Qualifier = null;

									IF (debug = &apos;Y&apos;) THEN
										call print(moduleName||&apos; : layerType=&apos;||NVL(layerType, &apos;null&apos;)||&apos;  metadataLineage:&apos;||NVL(metadataLineage,&apos;null&apos;));
										SET duration = CURRENT_TIMESTAMP - beginTS;
										SET message = moduleName||&apos; : &apos;||CAST(CURRENT_TIMESTAMP AS VARCHAR)||&apos; END GENERATE FORMATTING LAYER: DURATION=&apos;||CAST(duration AS VARCHAR)||
											&apos;    NUMBER OF RESOURCES CREATED=&apos;||NVL(NVL(CAST(numCreated AS VARCHAR),&apos;0&apos;),&apos;0&apos;)||&apos;  NUMBER OF RESOURCES UPDATED=&apos;||NVL(CAST(numUpdated AS VARCHAR),&apos;0&apos;);
										CALL print(message);
										CALL print(&apos;&apos;);
									END IF;
								ELSE
									IF (debug = &apos;Y&apos;) THEN
										SET duration = CURRENT_TIMESTAMP - beginTS;
										SET message = moduleName||&apos; : &apos;||CAST(CURRENT_TIMESTAMP AS VARCHAR)||&apos; SKIPPED FORMATTING LAYER: DURATION=&apos;||CAST(duration AS VARCHAR);
										CALL print(message);
										CALL print(&apos;&apos;);
									END IF;
								END IF;
							EXCEPTION
								ELSE
									RAISE ex VALUE CURRENT_EXCEPTION.TRACE;
							END;

							/*
								Generate Business Layer
							*/
							BEGIN INDEPENDENT TRANSACTION
								SET beginTS = CURRENT_TIMESTAMP;
								SET parentLayerType = layerType;
								SET layerType = &apos;BUSINESS&apos;;
								IF (businessLayerPath IS NOT NULL AND LENGTH(TRIM(businessLayerPath)) &gt; 0) then 
									SET targetPath = businessLayerPath;
									-- Remove any white space and / at the end if exists.
									IF (SUBSTRING(targetPath, LENGTH(targetPath), 1) = &apos;/&apos;) THEN
										SET targetPath = SUBSTRING(targetPath, 1, LENGTH(targetPath)-1);
									END IF;
									IF (debug = &apos;Y&apos;) THEN
										SET message = moduleName||&apos; : &apos;||CAST(beginTS AS VARCHAR)||&apos; BEGIN GENERATE BUSINESS LAYER: &apos;||NVL(targetPath,&apos;null&apos;);
										CALL print(message);
									END IF;
									-- Test for table names usage
									IF (Table_Names IS NULL) THEN
										SET Table_Names = Table_Names1;	-- This contains the original list
									ELSE
										SET Table_Names = Table_Names2;	-- This contains a modified list with prefixes
									END IF;

									-- Create the resources for this layer
									CALL /shared/ASAssets/Utilities/generate/helpers/createResourceProcess(
										parentLayerType, layerType, sourcePath, sourceType, targetPath, Table_Names, sep, 				-- Input params
										Tab_Prefix, Tab_Qualifier, overwrite, copyAnnotation, copySqlIndexes, copyForeignKeys, debug,	-- Input params
										numCreated, numUpdated, resultCursor);															-- Output params	
									FOR crp AS resultCursor DO
										SET resultRec = crp;
										-- Keep a running list of the metadata.  Initialize this list with [metadata path==&gt;metadata path]
										-- The first metadata path in the list will be replaced subsequently with the source path until
										-- the published layer points to the metadata path.
										IF (resultRec.parentLineagePath IS NOT NULL) THEN
											SET pos1 = INSTR(metadataLineage, resultRec.parentLineagePath||&apos;==&gt;&apos;);
											SET len = LENGTH(resultRec.parentLineagePath);
											SET pos2 = INSTR(metadataLineage, &apos;]&apos;, pos1+len+3);
											IF (pos1 &gt; 0) THEN
												-- Extract the corresponding metadata path for this resource
												SET resultRec.metadataLineagePath = SUBSTRING(metadataLineage, pos1+len+3, pos2-(pos1+len+3));
												-- Extract the resource name
												SET pos2 = INSTR(resultRec.metadataLineagePath, &apos;/&apos;, -1, 1);
												SET resultRec.metadataLineageName = SUBSTRING(resultRec.metadataLineagePath, pos2+1);
												-- Rewrite the source path with the current resource path
												SET metadataLineage = SUBSTRING(metadataLineage, 1, pos1-1) || resultRec.resPath || SUBSTRING(metadataLineage, pos1+len);
											END IF;
										END IF;
										-- Insert the record
										INSERT INTO generatedViewsCursor VALUES (resultRec);
									END FOR;
									SET sourcePath = targetPath;
									SET sourceType = &apos;CONTAINER&apos;;
									SET Tab_Prefix = null;
									SET Tab_Qualifier = null;

									IF (debug = &apos;Y&apos;) THEN
										call print(moduleName||&apos; : layerType=&apos;||NVL(layerType, &apos;null&apos;)||&apos;  metadataLineage:&apos;||NVL(metadataLineage,&apos;null&apos;));
										SET duration = CURRENT_TIMESTAMP - beginTS;
										SET message = moduleName||&apos; : &apos;||CAST(CURRENT_TIMESTAMP AS VARCHAR)||&apos; END GENERATE BUSINESS LAYER: DURATION=&apos;||CAST(duration AS VARCHAR)||
											&apos;    NUMBER OF RESOURCES CREATED=&apos;||NVL(CAST(numCreated AS VARCHAR),&apos;0&apos;)||&apos;  NUMBER OF RESOURCES UPDATED=&apos;||NVL(CAST(numUpdated AS VARCHAR),&apos;0&apos;);
										CALL print(message);
										CALL print(&apos;&apos;);
									END IF;
								ELSE
									IF (debug = &apos;Y&apos;) THEN
										SET duration = CURRENT_TIMESTAMP - beginTS;
										SET message = moduleName||&apos; : &apos;||CAST(CURRENT_TIMESTAMP AS VARCHAR)||&apos; SKIPPED BUSINESS LAYER: DURATION=&apos;||CAST(duration AS VARCHAR);
										CALL print(message);
										CALL print(&apos;&apos;);
									END IF;
								END IF;
							EXCEPTION
								ELSE
									RAISE ex VALUE CURRENT_EXCEPTION.TRACE;
							END;

							/*
								Generate Application Layer
							*/
							BEGIN INDEPENDENT TRANSACTION
								SET beginTS = CURRENT_TIMESTAMP;
								SET parentLayerType = layerType;
								SET layerType = &apos;APPLICATION&apos;;
								IF (applicationLayerPath IS NOT NULL AND LENGTH(TRIM(applicationLayerPath)) &gt; 0) then 
									SET targetPath = applicationLayerPath;
									-- Remove any white space and / at the end if exists.
									IF (SUBSTRING(targetPath, LENGTH(targetPath), 1) = &apos;/&apos;) THEN
										SET targetPath = SUBSTRING(targetPath, 1, LENGTH(targetPath)-1);
									END IF;
									IF (debug = &apos;Y&apos;) THEN
										SET message = moduleName||&apos; : &apos;||CAST(beginTS AS VARCHAR)||&apos; BEGIN GENERATE APPLICATION LAYER: &apos;||NVL(targetPath,&apos;null&apos;);
										CALL print(message);
									END IF;
									-- Test for table names usage
									IF (Table_Names IS NULL) THEN
										SET Table_Names = Table_Names1;	-- This contains the original list
									ELSE
										SET Table_Names = Table_Names2;	-- This contains a modified list with prefixes
									END IF;

									-- Create the resources for this layer
									CALL /shared/ASAssets/Utilities/generate/helpers/createResourceProcess(
										parentLayerType, layerType, sourcePath, sourceType, targetPath, Table_Names, sep, 				-- Input params
										Tab_Prefix, Tab_Qualifier, overwrite, copyAnnotation, copySqlIndexes, copyForeignKeys, debug,	-- Input params
										numCreated, numUpdated, resultCursor);															-- Output params	
									FOR crp AS resultCursor DO
										SET resultRec = crp;
										-- Keep a running list of the metadata.  Initialize this list with [metadata path==&gt;metadata path]
										-- The first metadata path in the list will be replaced subsequently with the source path until
										-- the published layer points to the metadata path.
										IF (resultRec.parentLineagePath IS NOT NULL) THEN
											SET pos1 = INSTR(metadataLineage, resultRec.parentLineagePath||&apos;==&gt;&apos;);
											SET len = LENGTH(resultRec.parentLineagePath);
											SET pos2 = INSTR(metadataLineage, &apos;]&apos;, pos1+len+3);
											IF (pos1 &gt; 0) THEN
												-- Extract the corresponding metadata path for this resource
												SET resultRec.metadataLineagePath = SUBSTRING(metadataLineage, pos1+len+3, pos2-(pos1+len+3));
												-- Extract the resource name
												SET pos2 = INSTR(resultRec.metadataLineagePath, &apos;/&apos;, -1, 1);
												SET resultRec.metadataLineageName = SUBSTRING(resultRec.metadataLineagePath, pos2+1);
												-- Rewrite the source path with the current resource path
												SET metadataLineage = SUBSTRING(metadataLineage, 1, pos1-1) || resultRec.resPath || SUBSTRING(metadataLineage, pos1+len);
											END IF;
										END IF;
										-- Insert the record
										INSERT INTO generatedViewsCursor VALUES (resultRec);
									END FOR;
									SET sourcePath = targetPath;
									SET sourceType = &apos;CONTAINER&apos;;
									SET Tab_Prefix = null;
									SET Tab_Qualifier = null;

									IF (debug = &apos;Y&apos;) THEN
										call print(moduleName||&apos; : layerType=&apos;||NVL(layerType, &apos;null&apos;)||&apos;  metadataLineage:&apos;||NVL(metadataLineage,&apos;null&apos;));
										SET duration = CURRENT_TIMESTAMP - beginTS;
										SET message = moduleName||&apos; : &apos;||CAST(CURRENT_TIMESTAMP AS VARCHAR)||&apos; END GENERATE APPLICATION LAYER: DURATION=&apos;||CAST(duration AS VARCHAR)||
											&apos;    NUMBER OF RESOURCES CREATED=&apos;||NVL(CAST(numCreated AS VARCHAR),&apos;0&apos;)||&apos;  NUMBER OF RESOURCES UPDATED=&apos;||NVL(CAST(numUpdated AS VARCHAR),&apos;0&apos;);
										CALL print(message);
										CALL print(&apos;&apos;);
									END IF;
								ELSE
									IF (debug = &apos;Y&apos;) THEN
										SET duration = CURRENT_TIMESTAMP - beginTS;
										SET message = moduleName||&apos; : &apos;||CAST(CURRENT_TIMESTAMP AS VARCHAR)||&apos; SKIPPED APPLICATION LAYER: DURATION=&apos;||CAST(duration AS VARCHAR);
										CALL print(message);
										CALL print(&apos;&apos;);
									END IF;
								END IF;
							EXCEPTION
								ELSE
									RAISE ex VALUE CURRENT_EXCEPTION.TRACE;
							END;

							/*
								Generate Published DB Layer
							*/
							BEGIN INDEPENDENT TRANSACTION
								SET beginTS = CURRENT_TIMESTAMP;
								SET parentLayerType = layerType;
								SET layerType = &apos;PUBLISHED&apos;;
								IF (publishedDBLayerPath IS NOT NULL AND LENGTH(TRIM(publishedDBLayerPath)) &gt; 0) then 
									SET targetPath = publishedDBLayerPath;
									-- Remove any white space and / at the end if exists.
									IF (SUBSTRING(targetPath, LENGTH(targetPath), 1) = &apos;/&apos;) THEN
										SET targetPath = SUBSTRING(targetPath, 1, LENGTH(targetPath)-1);
									END IF;
									IF (debug = &apos;Y&apos;) THEN
										SET message = moduleName||&apos; : &apos;||CAST(beginTS AS VARCHAR)||&apos; BEGIN GENERATE PUBLISHED DB LAYER: &apos;||NVL(targetPath,&apos;null&apos;);
										CALL print(message);
									END IF;
									-- Test for table names usage
									IF (Table_Names IS NULL) THEN
										SET Table_Names = Table_Names1;	-- This contains the original list
									ELSE
										SET Table_Names = Table_Names2;	-- This contains a modified list with prefixes
									END IF;

									-- Create the resources for this layer
									CALL /shared/ASAssets/Utilities/generate/helpers/createResourceProcess(
										parentLayerType, layerType, sourcePath, sourceType, targetPath, Table_Names, sep, 				-- Input params
										Tab_Prefix, Tab_Qualifier, overwrite, copyAnnotation, copySqlIndexes, copyForeignKeys, debug,	-- Input params
										numCreated, numUpdated, resultCursor);															-- Output params	
									FOR crp AS resultCursor DO
										SET resultRec = crp;
										-- Keep a running list of the metadata.  Initialize this list with [metadata path==&gt;metadata path]
										-- The first metadata path in the list will be replaced subsequently with the source path until
										-- the published layer points to the metadata path.
										IF (resultRec.parentLineagePath IS NOT NULL) THEN
											SET pos1 = INSTR(metadataLineage, resultRec.parentLineagePath||&apos;==&gt;&apos;);
											SET len = LENGTH(resultRec.parentLineagePath);
											SET pos2 = INSTR(metadataLineage, &apos;]&apos;, pos1+len+3);
											IF (pos1 &gt; 0) THEN
												-- Extract the corresponding metadata path for this resource
												SET resultRec.metadataLineagePath = SUBSTRING(metadataLineage, pos1+len+3, pos2-(pos1+len+3));
												-- Extract the resource name
												SET pos2 = INSTR(resultRec.metadataLineagePath, &apos;/&apos;, -1, 1);
												SET resultRec.metadataLineageName = SUBSTRING(resultRec.metadataLineagePath, pos2+1);
												-- Rewrite the source path with the current resource path
												SET metadataLineage = SUBSTRING(metadataLineage, 1, pos1-1) || resultRec.resPath || SUBSTRING(metadataLineage, pos1+len);
											END IF;
										END IF;
										-- Insert the record
										INSERT INTO generatedViewsCursor VALUES (resultRec);
									END FOR;

									IF (debug = &apos;Y&apos;) THEN
										call print(moduleName||&apos; : layerType=&apos;||NVL(layerType, &apos;null&apos;)||&apos;  metadataLineage:&apos;||NVL(metadataLineage,&apos;null&apos;));
										SET duration = CURRENT_TIMESTAMP - beginTS;
										SET message = moduleName||&apos; : &apos;||CAST(CURRENT_TIMESTAMP AS VARCHAR)||&apos; END GENERATE PUBLISHED DB LAYER: DURATION=&apos;||CAST(duration AS VARCHAR)||
											&apos;    NUMBER OF RESOURCES CREATED=&apos;||NVL(CAST(numCreated AS VARCHAR),&apos;0&apos;)||&apos;  NUMBER OF RESOURCES UPDATED=&apos;||NVL(CAST(numUpdated AS VARCHAR),&apos;0&apos;);
										CALL print(message);
										CALL print(&apos;&apos;);
									END IF;
								ELSE
									IF (debug = &apos;Y&apos;) THEN
										SET duration = CURRENT_TIMESTAMP - beginTS;
										SET message = moduleName||&apos; : &apos;||CAST(CURRENT_TIMESTAMP AS VARCHAR)||&apos; SKIPPED PUBLISHED DB LAYER: DURATION=&apos;||CAST(duration AS VARCHAR);
										CALL print(message);
										CALL print(&apos;&apos;);
									END IF;
								END IF;
							EXCEPTION
								ELSE
									RAISE ex VALUE CURRENT_EXCEPTION.TRACE;
							END;

							-- Reset the metadata lineage list
							SET metadataLineage = &apos;&apos;;
							-- Reset the prefix
							SET Tab_Prefix = prefix;
						END IF;
					END IF;

					-- Reset the table name lists
					SET Table_Names = null;
					SET Table_Names1 = &apos;&apos;;
					SET Table_Names2 = &apos;&apos;;

					-- Set the previous container path
					SET prevContainerPath = containerPath;
					SET prevContainerType = containerType;
				END IF;
			END IF;

			-- Initialize the layer types
			SET parentLayerType = null;
			SET layerType = &apos;METADATA&apos;;

			-- Resources that already exist and therefore were skipped.
			IF (r.&quot;action&quot; = &apos;SKIP&apos;) THEN
				-- Count the resources skipped including DATA_SOURCE and CONTAINER types
				SET numResourcesIntrospectSkip = numResourcesIntrospectSkip + 1;
				IF (r.&quot;type&quot; = &apos;TABLE&apos;) THEN
					-- Count the tables skipped and concat them to the introspect skip list
					SET numTablesIntrospectSkip = numTablesIntrospectSkip + 1;
					IF (LENGTH(tablesIntrospectSkip) &gt; 0) THEN
						SET tablesIntrospectSkip = tablesIntrospectSkip || &apos;,&apos;;
					END IF;
					-- Extract just the table name from the path which includes container and resource name
					SET Table_Name1 = r.&quot;path&quot;;
					IF (INSTR(Table_Name1, &apos;/&apos;) &gt; 0) THEN
						SET pos1 = INSTR(Table_Name1, &apos;/&apos;, -1, 1);
						IF (pos1 &gt; 0) THEN
							SET Table_Name1 = SUBSTRING(Table_Name1, pos1+1);
						END IF;
					END IF;
					-- Excel Non-ODBC resource subtype
					IF (r.subtype = &apos;EXCEL_NON_ODBC_POI&apos;) THEN
						-- Replace the slash with a dash.  e.g.  myexcel.xlsx/Sheet = myexcel.xlsx-Sheet1
						-- 	The container name acts as a qualifier for the sheet name which can be generic/same for different files thus resulting in collisions
						SET Table_Name2 = REPLACE(r.&quot;path&quot;, &apos;/&apos;, &apos;-&apos;);
					ELSE
						SET Table_Name2 = Table_Name1;
					END IF;
					SET tablesIntrospectSkip = tablesIntrospectSkip || r.&quot;path&quot;;

					-- Insert a record for this table
					INSERT INTO generatedViewsCursor VALUES (&apos;SKIPPED [EXISTS]&apos;, layerType, Table_Name1, datasourcePathMod||&apos;/&apos;||r.&quot;path&quot;, r.&quot;type&quot;, r.subtype, parentLayerType, null, Table_Name1, datasourcePathMod||&apos;/&apos;||r.&quot;path&quot;);

					-- Add tables into the table name list 1 representing the original source list.
					IF (LENGTH(Table_Names1) &gt; 0) THEN
						SET Table_Names1 = Table_Names1 || sep;
					END IF;
					SET Table_Names1 = Table_Names1 || Table_Name1;

					-- Add tables into the table name list 2 representing the target list.  If there is a prefix, then add it to the beginning of the table name.
					IF (LENGTH(Table_Names2) &gt; 0) THEN
						SET Table_Names2 = Table_Names2 || sep;
					END IF;
					IF (prefix IS NOT NULL) THEN
						SET Table_Names2 = Table_Names2 || prefix||Table_Name2;
					ELSE
						SET Table_Names2 = Table_Names2 || Table_Name2;
					END IF;

					-- Keep a running list of the metadata.  Initialize this list with [metadata path==&gt;metadata path]
					-- The first metadata path in the list will be replaced subsequently with the source path until
					-- the published layer points to the metadata path.
					SET metadataLineage = metadataLineage || &apos;[&apos; || datasourcePathMod || &apos;/&apos;|| r.&quot;path&quot; || &apos;==&gt;&apos; || datasourcePathMod || &apos;/&apos;|| r.&quot;path&quot; || &apos;]&apos;||CHR(10);
				END IF;
			END IF;

			-- Resources that did not exist and therefore were added.
			IF (r.&quot;action&quot; = &apos;ADD&apos;) THEN
				-- Count the resources added including DATA_SOURCE and CONTAINER types
				SET numResourcesIntrospectAdd = numResourcesIntrospectAdd + 1;
				IF (r.&quot;type&quot; = &apos;TABLE&apos;) THEN
					-- Count the tables added and concat them to the introspect add list
					SET numTablesIntrospectAdd = numTablesIntrospectAdd + 1;
					IF (LENGTH(tablesIntrospectAdd) &gt; 0) THEN
						SET tablesIntrospectAdd = tablesIntrospectAdd || &apos;,&apos;;
					END IF;
					-- Extract just the table name from the path which includes container and resource name
					SET Table_Name1 = r.&quot;path&quot;;
					IF (INSTR(Table_Name1, &apos;/&apos;) &gt; 0) THEN
						SET pos1 = INSTR(Table_Name1, &apos;/&apos;, -1, 1);
						IF (pos1 &gt; 0) THEN
							SET Table_Name1 = SUBSTRING(Table_Name1, pos1+1);
						END IF;
					END IF;
					-- Excel Non-ODBC resource subtype
					IF (r.subtype = &apos;EXCEL_NON_ODBC_POI&apos;) THEN
						-- Replace the slash with a dash.  e.g.  myexcel.xlsx/Sheet = myexcel.xlsx-Sheet1
						-- 	The container name acts as a qualifier for the sheet name which can be generic/same for different files thus resulting in collisions
						SET Table_Name2 = REPLACE(r.&quot;path&quot;, &apos;/&apos;, &apos;-&apos;);
					ELSE
						SET Table_Name2 = Table_Name1;
					END IF;
					SET tablesIntrospectAdd = tablesIntrospectAdd || r.&quot;path&quot;;

					-- Insert a record for this table
					INSERT INTO generatedViewsCursor VALUES (&apos;CREATED&apos;, layerType, Table_Name1, datasourcePathMod||&apos;/&apos;||r.&quot;path&quot;, r.&quot;type&quot;, r.subtype, parentLayerType, null, Table_Name1, datasourcePathMod||&apos;/&apos;||r.&quot;path&quot;);

					-- Add tables into the table name list 1 representing the original source list.
					IF (LENGTH(Table_Names1) &gt; 0) THEN
						SET Table_Names1 = Table_Names1 || sep;
					END IF;
					SET Table_Names1 = Table_Names1 || Table_Name1;

					-- Add tables into the table name list 2 representing the target list.  If there is a prefix, then add it to the beginning of the table name.
					IF (LENGTH(Table_Names2) &gt; 0) THEN
						SET Table_Names2 = Table_Names2 || sep;
					END IF;
					IF (prefix IS NOT NULL) THEN
						SET Table_Names2 = Table_Names2 || prefix||Table_Name2;
					ELSE
						SET Table_Names2 = Table_Names2 || Table_Name2;
					END IF;

					-- Keep a running list of the metadata.  Initialize this list with [metadata path==&gt;metadata path]
					-- The first metadata path in the list will be replaced subsequently with the source path until
					-- the published layer points to the metadata path.
					SET metadataLineage = metadataLineage || &apos;[&apos; || datasourcePathMod || &apos;/&apos;|| r.&quot;path&quot; || &apos;==&gt;&apos; || datasourcePathMod || &apos;/&apos;|| r.&quot;path&quot; || &apos;]&apos;||CHR(10);
				END IF;
			END IF;
		END FOR;

		IF (debug = &apos;Y&apos;) THEN
			SET duration = CURRENT_TIMESTAMP - beginTS;
			SET message = moduleName||&apos; : &apos;||CAST(CURRENT_TIMESTAMP AS VARCHAR)||&apos; END INTROSPECTION OF MEATADATA SOURCE: DURATION=&apos;||CAST(duration AS VARCHAR)||
				&apos;    NUMBER OF RESOURCES ADDED=&apos;||CAST(numResourcesIntrospectAdd AS VARCHAR)||&apos;  NUMBER OF RESOURCES SKIPPED=&apos;||CAST(numResourcesIntrospectSkip AS VARCHAR);
			CALL print(message);
			CALL print(&apos;&apos;);
		END IF;


	IF (debug = &apos;Y&apos;) THEN
		SET duration = CURRENT_TIMESTAMP - beginProc;
		SET message = moduleName||&apos; : &apos;||CAST(CURRENT_TIMESTAMP AS VARCHAR)||&apos; END GENERATE PROCEDURE DURATION=&apos;||CAST(duration AS VARCHAR);
		CALL print(message);
	END IF;
END</attribute>
  <attribute name="creationDate" type="LONG">1396452310047</attribute>
  <attribute name="creatorUserDomain" type="STRING">ldap</attribute>
  <attribute name="creatorUserName" type="STRING">zk5tunx</attribute>
  <attribute name="explicitly.designed" type="BOOLEAN">false</attribute>
  <attribute name="lastModifiedDate" type="LONG">1564746983967</attribute>
  <attribute name="lastModifiedUserDomain" type="STRING">composite</attribute>
  <attribute name="lastModifiedUserName" type="STRING">admin</attribute>
  <attribute name="model" type="NULL"/>
  <attribute name="native_only" type="STRING">false</attribute>
  <attribute name="references" type="MAP">
    <item>
      <key type="STRING">9/793</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">9/792</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/599</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/237</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/236</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/235</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/234</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/637</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/270</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/421</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/422</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/350</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/414</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/415</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/410</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/498</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/575</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/499</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/576</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/800</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/249</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">11/317</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/491</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">11/316</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/492</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">10/306</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/251</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/250</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/568</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/569</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/487</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/564</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/641</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/642</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/368</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/445</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/522</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/239</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/238</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/244</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/243</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/242</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/241</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/248</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/247</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/246</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/245</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/240</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/648</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">16/649</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
  </attribute>
</metadata>