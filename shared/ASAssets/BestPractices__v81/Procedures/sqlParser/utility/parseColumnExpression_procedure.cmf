<?xml version="1.1" encoding="UTF-8"?>
<!-- salt:44831da2-fa57-48b1-b3e8-4297d727cb06 -->
<metadata name="parseColumnExpression" path="/shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/parseColumnExpression" type="PROCEDURE" subtype="SQL_SCRIPT_PROCEDURE" changeToken="0">
  <annotation>	(c) 2017 TIBCO Software Inc.  All rights reserved.
	
	Except as specified below, this software is licensed pursuant to the Eclipse Public License v. 1.0.
	The details can be found in the file LICENSE.
	
	The following proprietary files are included as a convenience, and may not be used except pursuant
	to valid license to Composite Information Server or TIBCO® Data Virtualization Server:
	csadmin-XXXX.jar, csarchive-XXXX.jar, csbase-XXXX.jar, csclient-XXXX.jar, cscommon-XXXX.jar,
	csext-XXXX.jar, csjdbc-XXXX.jar, csserverutil-XXXX.jar, csserver-XXXX.jar, cswebapi-XXXX.jar,
	and customproc-XXXX.jar (where -XXXX is an optional version number).  Any included third party files
	are licensed under the terms contained in their own accompanying LICENSE files, generally named .LICENSE.txt.
	
	This software is licensed AS-IS. Support for this software is not covered by standard maintenance agreements with TIBCO.
	If you would like to obtain assistance with this software, such assistance may be obtained through a separate paid consulting
	agreement with TIBCO.
</annotation>
  <parameters>
    <parameter name="inColumnExpression" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="inFunctionList" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="inColumnList" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="inRecurseDepth" direction="IN" nullable="true">
      <datatype name="INTEGER" type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
    </parameter>
    <parameter name="functionList" direction="OUT" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="columnList" direction="OUT" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="recurseDepth" direction="OUT" nullable="true">
      <datatype name="INTEGER" type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
    </parameter>
  </parameters>
  <security>
    <owner user="admin" domain="composite"/>
    <privilege group="all" domain="composite" privileges="READ"/>
  </security>
  <dependency target="/shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/encodedValues" type="DEFINITION_SET">
    <datatype name="Tree" type="TREE" refId="1"></datatype>
  </dependency>
  <dependency target="/shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/getCodedString" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="inCodingType" direction="IN">
        <datatype type="STRING" minLength="1" maxLength="1"/>
      </element>
      <element name="inEncodingActions" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="codingList" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="inString" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="inModuleNameInvoking" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="inDebug" direction="IN">
        <datatype type="STRING" minLength="1" maxLength="1"/>
      </element>
      <element name="inStringName" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="outString" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/isReservedColumnList" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="inColumnList" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="columnList" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/parseArithmeticOperators" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="inColumnList" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="columnList" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/parseCase" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="inColumnExpression" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="function" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="columnList" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/parseColumnExpression" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="inColumnExpression" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="inFunctionList" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="inColumnList" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="inRecurseDepth" direction="IN">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
      <element name="functionList" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="columnList" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="recurseDepth" direction="OUT">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/parseConcat" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="inColumnExpression" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="concatVect" direction="OUT">
        <datatype type="ARRAY" maxLength="0">
          <itemDatatype>
            <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
          </itemDatatype>
        </datatype>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/parseFunction" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="inColumnExpression" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="function" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="columnList" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/parseInterval" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="inColumnExpression" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="outColumnExpression" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/removeColumnListDuplicates" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="inColumnList" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="columnList" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/BestPractices_v81/_ProjectMaintenance/defaultValues" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1"></datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/log/logDebugMessage" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="moduleName" direction="IN">
        <datatype referenceDefinitionSet="/shared/ASAssets/Utilities/TypeDefinitions" referenceType="moduleNameType" type="STRING" maxLength="4096"/>
      </element>
      <element name="debug" direction="IN">
        <datatype type="STRING" maxLength="1"/>
      </element>
      <element name="messageText" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/string/TextUtils/RegexReplace" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="Input Text" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="Regular Expression" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="Replacement Text" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="Occurrence" direction="IN">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
      <element name="result" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/string/extractDelimitedText" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="inputString" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="delimiter" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="occurrence" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="reverseInputText" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="reverseOutput" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="trimText" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="includeDelimiter" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="result" direction="OUT">
        <datatype type="TABLE" refId="2">
          <element name="object">
            <datatype type="STRING" maxLength="2147483647"/>
          </element>
        </datatype>
      </element>
    </datatype>
  </dependency>
  <attribute name="Script" type="STRING">/*
	parseColumnExpression - parse the column expression and extract the function list and column list
		Assume no alias on the end of the expression as it has already been extracted from the text to simplify
		the extraction algorithm.

	Exceptions:  none

* Not Supported
	1. 	XML Functions

* Supported column expressions:
	1. Simple column expression (expr) - table.column or column [i.e. table.col]
		a. select column 				-- column name alone
		b. select column alias
		c. select table1.column
		d. select table1.column alias
	2. Simple Composite or Custom Function with column expression - function(expr) [i.e. trim(col), myfunc(col1)]
	3. Simple multi-expression Composite or Custom Function - function(expr1, expr2, expr3) [i.e. SUBSTRING(col,1,1), myfunc(col1,2,col2]
	4. Simple case syntax
		CASE &lt;comparison-value&gt;
			WHEN &lt;conditional-expression 1&gt; THEN &lt;scalar-expression 1&gt;
			WHEN &lt;conditional-expression 2&gt; THEN &lt;scalar-expression 2&gt;
			WHEN &lt;conditional-expression 3&gt; THEN &lt;scalar-expression 3&gt;
			[ELSE &lt;default-scalar-expression&gt;]
		END
	5. Simple case Searched Syntax
		CASE
			WHEN &lt;conditional-expression 1&gt; THEN &lt;scalar-expression 1&gt;
			WHEN &lt;conditional-expression 2&gt; THEN &lt;scalar-expression 2&gt;
			WHEN &lt;conditional-expression 3&gt; THEN &lt;scalar-expression 3&gt;
			[ELSE &lt;default-scalar-expression&gt;]
		END
	6. Simple Concatenation syntax using pipes - expr1 || expr2 || expr3
	7. Simple Position statement - POSITION(expr1 IN expr2) 
	8. Simple Cast statement - CAST(expr AS TYPE)
	9. Simple Extract statement - EXTRACT (&lt;field name&gt; FROM &lt;value&gt;)
	10. Simple Interval Day statement - INTERVAL &apos;&lt;literal&gt;&apos; [DAY,HOUR,MINUTE,SECOND](precision) TO [HOUR,MINUTE,SECOND](precision)
	11. Simple Interval Year statement - INTERVAL &apos;&lt;literal&gt;&apos; [YEAR,MONTH](precision) TO [MONTH](precision)
	12. Multi-expression statements may contain any number of expressions embedded in other expressions.
		Multi-expression statements may begin with any valid composite or custom function
		i.e. case trim(CAST (TRIM(col1) as varchar(255))) when 1 then &apos;a&apos; when 2 then col2 else table.col3 end

	Modified Date:	Modified By:		CSW Version:	Reason:
	11/11/2011		Mike Tinius			5.2.0			Created new
	03/15/2013		Mike Tinius			5.2.0			Modifications for Best Practices 7.0
	11/20/2014		Alex Dedov			6.2.6			8.1.5: Commented code that causes infinite recursion loop 
	11/20/2014		Mike Tinius			6.2.6			8.1.5: Added &apos;P&apos; to getCodedString(&apos;D&apos;, &apos;P&apos;, ...) invocation because of a change to getCodedString.
	03/02/2018		Mike Tinius			7.0.5			Replaced RegexSplit with extractDelimitedText
	04/15/2019		Mike Tinius			7.0.8			B.P. 2019.200: Added scriptsPath for flexibility of the location of the _scripts folder.
																	   Changed custom functions to explicit paths.

	(c) 2017 TIBCO Software Inc.  All rights reserved.
	
	Except as specified below, this software is licensed pursuant to the Eclipse Public License v. 1.0.
	The details can be found in the file LICENSE.
	
	The following proprietary files are included as a convenience, and may not be used except pursuant
	to valid license to Composite Information Server or TIBCO® Data Virtualization Server:
	csadmin-XXXX.jar, csarchive-XXXX.jar, csbase-XXXX.jar, csclient-XXXX.jar, cscommon-XXXX.jar,
	csext-XXXX.jar, csjdbc-XXXX.jar, csserverutil-XXXX.jar, csserver-XXXX.jar, cswebapi-XXXX.jar,
	and customproc-XXXX.jar (where -XXXX is an optional version number).  Any included third party files
	are licensed under the terms contained in their own accompanying LICENSE files, generally named .LICENSE.txt.
	
	This software is licensed AS-IS. Support for this software is not covered by standard maintenance agreements with TIBCO.
	If you would like to obtain assistance with this software, such assistance may be obtained through a separate paid consulting
	agreement with TIBCO.
*/
PROCEDURE parseColumnExpression(
--Examples:
-- position ( extract( year from orderdate )    in   upper( col2 ) )
-- concat ( RPAD ( Orders.Phone_Number,&apos; &apos;,12 ) , LPAD ( Customers.Zip,&apos; &apos;,2 ) )
-- TRIM(UPPER(SUBSTRING(col,1,10)))
-- SUBSTRING(TRIM(UPPER(col)),1,10)
-- RPAD(UPPER(col),5,&apos; &apos;)
-- case col1 when 1 then &apos;a&apos; when 2 then &apos;b&apos; else &apos;c&apos; end 
-- case col1 when col2 then &apos;a&apos; when 2 then col3 else col4 end 
-- case trim(rpad(col1,&apos;-&apos;,3)) when 1 then &apos;a&apos; when 2 then &apos;b&apos; else &apos;c&apos; end
-- case trim(CAST(TRIM(col1) as varchar(255) ))when 1 then &apos;a&apos; when 2 then &apos;b&apos; else &apos;c&apos; end
	IN	inColumnExpression	LONGVARCHAR, -- The column text to pars
	IN  inFunctionList		LONGVARCHAR,
	IN  inColumnList		LONGVARCHAR,
	IN  inRecurseDepth		INTEGER,	-- First time through, set to 0 indicating parent
	OUT functionList		LONGVARCHAR,
	OUT columnList			LONGVARCHAR,
	OUT recurseDepth		INTEGER
)
BEGIN
	DECLARE moduleName			VARCHAR DEFAULT &apos;parseColumnExpression&apos;;
	DECLARE debug				CHAR(1) DEFAULT /shared/ASAssets/BestPractices_v81/&quot;_ProjectMaintenance&quot;/defaultValues.debugSqlParser3;
	DECLARE sep					VARCHAR DEFAULT &apos;^&apos;; -- separator
	DECLARE columnExpressionTmp	LONGVARCHAR DEFAULT inColumnExpression;
	DECLARE columnExpression	LONGVARCHAR DEFAULT &apos;&apos;;
	DECLARE i,j					INTEGER DEFAULT 1;
	DECLARE ch_					CHAR(1);
	DECLARE quote				INTEGER DEFAULT 0; -- 0=off, 1=on -- quotes come in pairs so turn on when 1st one found and turn off when second one found.  Everything in between is ignored.
	DECLARE doubleQuote			INTEGER DEFAULT 0; -- 0=off, 1=on -- quotes come in pairs so turn on when 1st one found and turn off when second one found.  Everything in between is ignored.
	DECLARE pipePair			BOOLEAN DEFAULT FALSE;
	DECLARE leftParenBeg		INTEGER;
	DECLARE rightParenEnd		INTEGER;
	DECLARE casePos				INTEGER;
	DECLARE caseEndPos			INTEGER;
	DECLARE begPos 				INTEGER;
	DECLARE body				LONGVARCHAR;
	DECLARE contents			LONGVARCHAR;
	DECLARE function			LONGVARCHAR;
	DECLARE concatVect			VECTOR(LONGVARCHAR);
	DECLARE exprVect			VECTOR(LONGVARCHAR) DEFAULT VECTOR[null];
	DECLARE startTime			TIMESTAMP DEFAULT CURRENT_TIMESTAMP;
	DECLARE debugTime			CHAR(1) DEFAULT /shared/ASAssets/BestPractices_v81/&quot;_ProjectMaintenance&quot;/defaultValues.debugTime;
	DECLARE encodedComma 		VARCHAR DEFAULT /shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/encodedValues.encodedComma;  	-- _002c -- &apos;,&apos; comma
	DECLARE regexReplacePatternSingleQuote VARCHAR DEFAULT &apos;(?=[^&apos;&apos;]{0,255}&apos;&apos;(?:[^&apos;&apos;\r\n]{0,255}&apos;&apos;[^&apos;&apos;]{0,255}&apos;&apos;){0,1024}[^&apos;&apos;\r\n]{0,1024}$)&apos;;
	DECLARE regexPattern		LONGVARCHAR;
	DECLARE regexReplaceChars	LONGVARCHAR;
	DECLARE ascii_char			CHAR(1);

	DECLARE x INTEGER;

--------------------------------
-- INITIALIZATION:
--------------------------------
	-- Initialize outgoing variables;
	if (inFunctionList is not null) then
		set functionList = inFunctionList;
	else
		set functionList = &apos;&apos;;
	end if;
	if (inColumnList is not null) then
		set columnList = inColumnList;
	else
		set columnList = &apos;&apos;;
	end if;
	if (inRecurseDepth is not null) then
		set recurseDepth = inRecurseDepth;
	else
		set recurseDepth = 0;
	end if;

	-- DEBUG
	if (debug = &apos;Y&apos;) then
		call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;---------------------- INVOCATION -------------------&apos;);
		call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;Original:: Depth=&apos;||recurseDepth||
				&apos;  columnExpression=[&apos;||NVL(inColumnExpression,&apos;null&apos;)||&apos;]  inFunctionList=[&apos;||NVL(inFunctionList,&apos;null&apos;)||&apos;]  inColumnList=[&apos;||NVL(inColumnList,&apos;null&apos;)||&apos;]&apos;);
	end if;

--------------------------------
-- PRE-PARSING PREPARATION:
--------------------------------
	/* DECODE encoded characters
		-- Replace any encoded characters with the decoded character as shown in the chart below
			encodedSpace 	-- _0020 -- &apos; &apos; space
			encodedPeriod 	-- _002e -- &apos;.&apos; period
			encodedPipe 	-- _007c -- &apos;|&apos; pipe
			encodedComma 	-- _002c -- &apos;,&apos; comma
			encodedOpFact	-- _0021 -- &apos;!&apos; factorial operator
			encodedOpMod	-- _0025 -- &apos;%&apos; modulo operator
			encodedLParen	-- _0028 -- &apos;(&apos; left parenthesis
			encodedRParen	-- _0029 -- &apos;)&apos; right parenthesis
			encodedOpMult	-- _002a -- &apos;*&apos; multiply operator
			encodedOpAdd	-- _002b -- &apos;+&apos; addition operator
			encodedOpSub	-- _002d -- &apos;-&apos; subtraction operator
			encodedOpDiv	-- _002f -- &apos;/&apos; division operator
	*/

	-- Remomve special characters only on the first invocation of this procedure
	IF (recurseDepth = 0) THEN

		-- Decode the encoded values in the codingList for parenthesis only
		IF (POSITION(encodedComma IN columnExpressionTmp) &gt; 0) THEN
			call /shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/getCodedString(&apos;D&apos;, &apos;P&apos;, encodedComma, columnExpressionTmp, moduleName, &apos;N&apos;, &apos;columnExpressionTmp&apos;, columnExpressionTmp);
			if (debug = &apos;Y&apos;) then
				call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;decode columnExpressionTmp=&apos;||columnExpressionTmp);
			end if;
		END IF;
		-- Remove multiple spaces and trim the result
		set columnExpressionTmp = REPLACE(columnExpressionTmp,&apos;||&apos;,&apos; || &apos;);
		set columnExpressionTmp = REPLACE(columnExpressionTmp,&apos;(&apos;,&apos; ( &apos;);
		set columnExpressionTmp = REPLACE(columnExpressionTmp,&apos;)&apos;,&apos; ) &apos;);
		set columnExpressionTmp = REPLACE(columnExpressionTmp,&apos;  &apos;,&apos; &apos;);
		set columnExpression = TRIM(columnExpressionTmp);

		-- Remove all text contained within single quotes by first replace all ASCII values within single quotes with an empty character
		--   1. Create the list of characters to replace using regex.  They are placed within square brackets [].
		set regexReplaceChars = &apos; !&quot;#\$%&amp;\(\)\*+,-\.\/0-9:;&lt;=&gt;?@A-Za-z\[\\\]^_`\{\|\}~&apos;;
		--   2. Create the regex pattern by concatening the replace characters with the regex replace pattern for single quotes
		set regexPattern = &apos;[&apos;||regexReplaceChars||&apos;]&apos;||regexReplacePatternSingleQuote;
		--   3. Execute the regex replace
		if (debug = &apos;Y&apos;) then
			call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;regex regexReplaceChars=&apos;||NVL(regexReplaceChars,&apos;null&apos;)||&apos;  regexReplacePatternSingleQuote=&apos;||NVL(regexReplacePatternSingleQuote,&apos;null&apos;));
		end if;
		call /shared/ASAssets/Utilities/string/TextUtils/RegexReplace(columnExpression, regexPattern, &apos;&apos;, 0, columnExpression);
		--   4. Print debug
		if (debug = &apos;Y&apos;) then
			call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;modified1 regex columnExpression=[&apos;||NVL(columnExpression,&apos;null&apos;)||&apos;]&apos;);
		end if;
		--   5. Replace all single quote patterns &apos;&apos; with empty character
		set columnExpression = REPLACE(columnExpression, &apos;&apos;&apos;&apos;&apos;&apos;, &apos;&apos;);
		--   6. Print debug
		if (debug = &apos;Y&apos;) then
			call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;modified1 replace columnExpression=[&apos;||NVL(columnExpression,&apos;null&apos;)||&apos;]&apos;);
		end if;

		--   7. Check to see if there is still a single quote that exists
		IF (POSITION(&apos;&apos;&apos;&apos; IN columnExpression) &gt; 0) THEN
			set regexReplaceChars = &apos;&apos;;
			set i = 128;
			WHILE (i &lt;= 255) DO
				set ascii_char = CHR(i);
				if (ascii_char is not null and LENGTH(ascii_char) &gt; 0) then
					set regexReplaceChars = regexReplaceChars || ascii_char;
				end if;
				set i = i + 1;
			END WHILE;
			set regexPattern = &apos;[&apos;||regexReplaceChars||&apos;]&apos;||regexReplacePatternSingleQuote;
			--   8. Execute the regex replace
			if (debug = &apos;Y&apos;) then
				call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;regex extended regexReplaceChars=&apos;||NVL(regexReplaceChars,&apos;null&apos;)||&apos;  regexReplacePatternSingleQuote=&apos;||NVL(regexReplacePatternSingleQuote,&apos;null&apos;));
			end if;
			call /shared/ASAssets/Utilities/string/TextUtils/RegexReplace(columnExpression, regexPattern, &apos;&apos;, 0, columnExpression);
			--   9. Print debug
			if (debug = &apos;Y&apos;) then
				call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;modified2 regex columnExpression=[&apos;||NVL(columnExpression,&apos;null&apos;)||&apos;]&apos;);
			end if;
			--   10. Replace all single quote patterns &apos;&apos; with empty character
			set columnExpression = REPLACE(columnExpression, &apos;&apos;&apos;&apos;&apos;&apos;, &apos;&apos;);
			--   11. Print debug
			if (debug = &apos;Y&apos;) then
				call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;modified2 replace columnExpression=[&apos;||NVL(columnExpression,&apos;null&apos;)||&apos;]&apos;);
			end if;
		END IF;
/*
		-- Remove all contents with single quotes &apos;&apos;.  These literal values are not captured.  Makes parsing easier to remove up front.
		-- Remove all horizontal tab, newline, vertical tab or carriage return
		WHILE (i &lt;= LENGTH(columnExpressionTmp) ) DO
			set ch = SUBSTRING(columnExpressionTmp,i,1);

			-- When a single quote is found turn off processing until the end quote is found.  Nothing should be processed in between quotes
			IF (ch = &apos;&apos;&apos;&apos;) THEN
				IF (quote = 0) THEN
					set quote = 1;
				ELSE
					set quote = 0;
				END IF;
			END IF;

			-- When a double quote is found replace all spaces within the double quotes with an encoded space (_0020) so the parsing works.
			-- If the double quote is inside a single quote like &apos;&quot;&apos; || var || &apos;&quot;&apos; then it is a constant not a qualifier
			IF (ch = &apos;&quot;&apos; and quote = 0) THEN
				IF (doubleQuote = 0) THEN
					set doubleQuote = 1;
				ELSE
					set doubleQuote = 0;
				END IF;
			END IF;

			-- Double Quote takes precedence over sinqle quote as you cannot have a single quote within the boundaries of a double quote
			IF (doubleQuote = 1) THEN
				/*
					Encode any special characters that are contained inside the double quotes which are actually column names.
					e.g.  sheet1.&quot;Physical Name (Table/Column)&quot; -- without the encoding, this would actually be interpreted as a function
					       because of the left and right parenthesis and an arithmetic operation because of the forward slash (division operater).
							encodedSpace	- &apos;_0020&apos;; -- &apos; &apos; space
							encodedOpFact	- &apos;_0021&apos;; -- &apos;!&apos; factorial operator
							encodedOpMod	- &apos;_0025&apos;; -- &apos;%&apos; modulo operator
							encodedLParen	- &apos;_0028&apos;; -- &apos;(&apos; left parenthesis
							encodedRParen	- &apos;_0029&apos;; -- &apos;)&apos; right parenthesis
							encodedOpMult	- &apos;_002a&apos;; -- &apos;*&apos; multiply operator
							encodedOpAdd	- &apos;_002b&apos;; -- &apos;+&apos; addition operator
							encodedOpSub	- &apos;_002d&apos;; -- &apos;-&apos; subtraction operator
							encodedOpDiv	- &apos;_002f&apos;; -- &apos;/&apos; division operator
				* /
				CASE ch
					WHEN &apos; &apos; THEN set ch_ = encodedSpace; 	-- &apos;_0020&apos;
					WHEN &apos;!&apos; THEN set ch_ = encodedOpFact; 	-- &apos;_0021&apos;
					WHEN &apos;%&apos; THEN set ch_ = encodedOpMod; 	-- &apos;_0025&apos;
					WHEN &apos;(&apos; THEN set ch_ = encodedLParen; 	-- &apos;_0028&apos;
					WHEN &apos;)&apos; THEN set ch_ = encodedRParen; 	-- &apos;_0029&apos;
					WHEN &apos;*&apos; THEN set ch_ = encodedOpMult; 	-- &apos;_002a&apos;
					WHEN &apos;+&apos; THEN set ch_ = encodedOpAdd; 	-- &apos;_002b&apos;
					WHEN &apos;-&apos; THEN set ch_ = encodedOpSub; 	-- &apos;_002d&apos;
					WHEN &apos;/&apos; THEN set ch_ = encodedOpDiv; 	-- &apos;_002f&apos;
					ELSE
						set ch_ = ch;
				END CASE;
				-- Concat the normal or encoded character
				set columnExpression = columnExpression || ch_;				
			ELSE
				IF (quote = 0 and ch &lt;&gt; &apos;&apos;&apos;&apos;) THEN
					-- append the character as long as it is not a horizontal tab, newline, vertical tab or carriage return
					-- otherwise replace the following with a space: 
					--     chr(9)=horizontal tab, chr(10)=newline, chr(11)=vertical tab, chr(13)=carriage return
					IF (ch = chr(9) or ch = chr(10) or ch = chr(11) or ch = chr(13)) THEN
						set columnExpression = columnExpression || &apos; &apos;;
					ELSE
						-- If there are any functions present, make sure there are spaces around the begin/end parenthesis.  
						-- If pipe symbols, make sure the concat symbol is surrounded by spaces for parsing
						--    Both actions will become important during parsing
						if ( ch = &apos;(&apos; or ch = &apos;)&apos; or ch = &apos;|&apos; ) then
							if (ch = &apos;|&apos;) then
								if (not pipePair) then -- found the first pipePair so put a space before it
									set columnExpression = columnExpression || &apos; &apos;||ch;
									set pipePair = true; -- turn on the pipe pair
								else -- found the second pipePair so put a space after it
									set columnExpression = columnExpression || ch||&apos; &apos;;
									set pipePair = false; -- turn off the pipe pair
								end if;
							else
								if (pipePair) then -- Make sure to turn off any single pipes found in the text
									set pipePair = false;
								end if;
								set columnExpression = columnExpression || &apos; &apos;||ch||&apos; &apos;;
							end if;
						else
							set columnExpression = columnExpression || ch;
						end if;
					END IF;
				END IF;
			END IF;
			set i = i + 1;
		END WHILE;
*/
		-- DEBUG
--		call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;modified1 columnExpression=[&apos;||NVL(columnExpression,&apos;null&apos;)||&apos;]&apos;);

		-- parseInterval(): 
		-- Parse out the INTERVAL expression and set to blanks as INTERVAL does not contain any relevant column data.
		-- This only has to be done once for the incoming expression when depth=0
		call /shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/parseInterval(columnExpression, columnExpression);

		-- DEBUG
		if (debug = &apos;Y&apos;) then
			call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;modified3 columnExpression=[&apos;||NVL(columnExpression,&apos;null&apos;)||&apos;]&apos;);
		end if;
	ELSE
		set columnExpression = TRIM(columnExpressionTmp);
	END IF;
--------------------------------
-- CONCATENTATION PARSING:
--------------------------------
	-- Split the incoming column expression by the carat symbol &apos;^&apos;
	-- Since this procedure is recursive, this procedure may be producing carat separate expressions for example:
	--     [Depth-0]columnExpression=concat(trim(col1),trim(col2)) --&gt; 
	--        [Depth-1]columnExpression=trim(col1)^trim(col2)
	--           [Depth-2]columnExpression=col1
	--           [Depth-2]columnExpression=col2
	set i = 1;
	for r as 
		select * from /shared/ASAssets/Utilities/string/extractDelimitedText(columnExpression,sep,0,0,0,1,0)
		where object is not null and length(object) &gt; 0
	do
		set columnExpression = r.object;

		-- DEBUG
		if (debug = &apos;Y&apos;) then
			call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;split...columnExpression=&apos;||NVL(columnExpression,&apos;null&apos;));
		end if;

		-- parseConcat(): Parse the column expression and extract the concatenation parts if they exist.  
		--   concatFound &gt; 0 if concat &apos;||&apos; is primary
		call /shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/parseConcat(columnExpression, concatVect);

		-- DEBUG
		if (debug = &apos;Y&apos;) then
			call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;after parseConcat - concat vector len=&apos;||CARDINALITY(concatVect));
		end if;

		-- Add the results of the concatenation parsing vector to the existing expression vector
		if (CARDINALITY(concatVect) = 0) then
			-- DEBUG
			if (debug = &apos;Y&apos;) then
				call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;exprVect size=0&apos;);
			end if;
			set exprVect[i] = columnExpression;
			set exprVect = extend(exprVect,1);
			set i = i + 1;
		else
			set j = 1;
			while (j &lt;= CARDINALITY(concatVect)) do
				set exprVect[i] = concatVect[j];
				-- DEBUG
				if (debug = &apos;Y&apos;) then
					call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;exprVect[&apos;||j||&apos;]=&apos;||NVL(exprVect[i],&apos;null&apos;));
				end if;
				set exprVect = extend(exprVect,1);
				set j = j + 1;
				set i = i + 1;
			end while;
		end if;
	end for;
	-- truncate the extra entry.
	set exprVect = truncate(exprVect,1);

--------------------------------
-- RECURSIVE EXPRESSION ITERATION:
--------------------------------
	-- Loop through the list of concatenations or the single expression if no concat expressions
	set j = 1;
	while (j &lt;= CARDINALITY(exprVect)) do
		set columnExpression = TRIM(exprVect[j]); -- Get the columnExpression from the vector
		set leftParenBeg =  POSITION(&apos;(&apos; IN columnExpression);	-- determine the beginning of a function
		set rightParenEnd =  POSITION(&apos;)&apos; IN columnExpression);	-- determine the end of a function
		set casePos = POSITION(&apos;CASE &apos; IN UPPER(columnExpression)); -- determine if the expression contains CASE
		if leftParenBeg is null then set leftParenBeg = 0; end if;
		if rightParenEnd is null then set rightParenEnd = 0; end if;
		if casePos is null then set casePos = 0; end if;

		-- DEBUG
		if (debug = &apos;Y&apos;) then
			call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;while loop being: vector...columnExpression=[&apos;||NVL(columnExpression,&apos;null&apos;)||&apos;]  leftParenBeg=&apos;||leftParenBeg||&apos;  rightParenEnd=&apos;||rightParenEnd||&apos;  casePos=&apos;||casePos);
		end if;

-- USE CASE: [no function, no case]
		if (leftParenBeg = 0 and casePos = 0) then 							
			-- DEBUG
			if (debug = &apos;Y&apos;) then
				call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;pattern found: [table.col1 or col1]&apos;);
			end if;

			-- Simple table.column alias or column alias or column use case
			set function = &apos;&apos;;
			-- parseArithmeticOperators(): Parse out the Arithmetic expressions
			call /shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/parseArithmeticOperators(TRIM(columnExpression),contents);
			-- isReservedColumnList(): Parse out the reserved words
			call /shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/isReservedColumnList(contents,contents);

			-- DEBUG
			if (debug = &apos;Y&apos;) then
				call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;[no function, no case] function=[&apos;||NVL(function,&apos;null&apos;)||&apos;] contents=[&apos;||NVL(contents,&apos;null&apos;)||&apos;]&apos;);
			end if;

-- USE CASE: [HAS FUNCTION, no case]
		elseif (leftParenBeg &gt; 0 and casePos = 0) then 						
			-- DEBUG
			if (debug = &apos;Y&apos;) then
				call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;pattern found: [FUNCTION(table.col1 or col1)]&apos;);
			end if;

			-- parseFunction(): parse out the functions
			call /shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/parseFunction(columnExpression,function,contents);
			-- DEBUG
			if (debug = &apos;Y&apos;) then
				call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;[HAS FUNCTION, no case] function=[&apos;||NVL(function,&apos;null&apos;)||&apos;] contents=[&apos;||NVL(contents,&apos;null&apos;)||&apos;]&apos;);
			end if;

-- USE CASE: [no function, HAS CASE]
		elseif (leftParenBeg = 0 and casePos &gt; 0) then 						
			-- DEBUG
			if (debug = &apos;Y&apos;) then
				call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;pattern found: [CASE expression]&apos;);
			end if;

			-- parseCase(): Handle both styles of CASE
			--   &quot;Simple Case&quot; Pattern: CASE expr1 WHEN expr2 THEN res1 WHEN val2 THEN res2 ELSE res3 END
			--   &quot;Searched Case&quot; Pattern: CASE WHEN expr1 [&lt;, =, &gt;, &lt;=, &gt;=, &lt;&gt;] expr2 THEN res1 ELSE res2 END
			call /shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/parseCase(columnExpression,function,contents);

			-- DEBUG
			if (debug = &apos;Y&apos;) then
				call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;[no function, HAS CASE] function=[&apos;||NVL(function,&apos;null&apos;)||&apos;] contents=[&apos;||NVL(contents,&apos;null&apos;)||&apos;]&apos;);
			end if;

	/***************************
	NEED TO WORK ON THIS USE CASE
	***************************/
-- USE CASE: [HAS FUNCTION, HAS CASE]
		else --(leftParenBeg &gt; 0 and casePos &gt; 0) then 						
			set begPos = POSITION(&apos;(&apos; IN columnExpression);
			set caseEndPos = POSITION(&apos;END&apos; IN UPPER(columnExpression));

-- USE CASE: [HAS FUNCTION (precendence), has case]
			if (begPos &lt; casePos) then -- function takes precedence over case	
				-- DEBUG
				if (debug = &apos;Y&apos;) then
					call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;pattern found function([case]): [FUNCTION(CASE expr WHEN x THEN y ELSE z END)]&apos;);
				end if;

				-- parseFunction(): parse out the functions
				call /shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/parseFunction(columnExpression,function,contents);

				-- DEBUG
				if (debug = &apos;Y&apos;) then
					call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;[HAS FUNCTION (precendence), has case] function=[&apos;||NVL(function,&apos;null&apos;)||&apos;] contents=[&apos;||NVL(contents,&apos;null&apos;)||&apos;]&apos;);
				end if;

-- USE CASE: [has function, HAS CASE (precendence)]
			else -- (begPos &gt; casePos) function is contained within the case, therefore CASE takes precendence 
				-- DEBUG
				if (debug = &apos;Y&apos;) then
					call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;pattern found (case [concat] end): [CASE expr||expr WHEN x THEN y ELSE z END]&apos;);
				end if;

				-- parseCase(): Handle both styles of CASE
				--   &quot;Simple Case&quot; Pattern: CASE expr1 WHEN expr2 THEN res1 WHEN val2 THEN res2 ELSE res3 END
				--   &quot;Searched Case&quot; Pattern: CASE WHEN expr1 [&lt;, =, &gt;, &lt;=, &gt;=, &lt;&gt;] expr2 THEN res1 ELSE res2 END
				call /shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/parseCase(columnExpression,function,contents);

				-- DEBUG
				if (debug = &apos;Y&apos;) then
					call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;[has function, HAS CASE (precendence)] function=[&apos;||NVL(function,&apos;null&apos;)||&apos;] contents=[&apos;||contents||&apos;]&apos;);
				end if;
			end if;
		end if;

		-- Capture the function in the function list
		if (function IS NOT NULL AND LENGTH(&apos;|&apos;||function||&apos;|&apos;) &gt; 2) then  --notEmpty
			if (functionList IS NOT NULL AND LENGTH(&apos;|&apos;||functionList||&apos;|&apos;) &gt; 2) then  --notEmpty
				set functionList = functionList || sep;
			end if;
			set functionList = functionList || function;
		end if;

		-- Capture the contents from the above invocations into the column list
		-- May need to recursively invoke &quot;parseColumnExpression&quot; again if there are more functions or case statements to parse.
		if (contents IS NOT NULL AND LENGTH(&apos;|&apos;||contents||&apos;|&apos;) &gt; 2) then  --notEmpty
			-- DEBUG
			if (debug = &apos;Y&apos;) then
				call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;contents=&apos;||NVL(contents,&apos;null&apos;));
			end if;

			-- Look for spaces or functions and keep parsing recursively
			if (POSITION(&apos; &apos; IN contents) &gt; 0 OR POSITION(&apos;(&apos; IN contents) &gt; 0) then
				-- Increment the recursion depth which provides an inidicator of how many times this function is invoked recursively
				set recurseDepth = recurseDepth + 1;

-- 20141112#DA Begin# Commented code causes infinite recursion loop 
-- RECURSIVE INVOCATION to &quot;parseColumnExpression()&quot;
				--call /shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/parseColumnExpression(
						--contents,functionList,columnList,recurseDepth, 	-- INPUT
						--functionList,columnList,recurseDepth);			-- OUTPUT

				SET x = POSITION(&apos; &apos; IN contents) ;
				IF x = 0 THEN 
					SET x = POSITION(&apos;(&apos; IN contents) ;
				END IF ;
				--CALL PRINT (&apos;parseColumnExpression calling itself with &apos;||SUBSTRING(contents,1,x-1));
				call /shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/parseColumnExpression(
						SUBSTRING(contents,1,x-1),
						functionList,columnList,recurseDepth,
						functionList,columnList,recurseDepth) ;
					
				--CALL PRINT(&apos;parseColumnExpression calling itself with &apos;||SUBSTRING(contents,x));
				call /shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/parseColumnExpression(
						SUBSTRING(contents,x),
						functionList,columnList,recurseDepth, 
						functionList,columnList,recurseDepth);
-- 20141112#DA End#

			else
				-- Add a separator &apos;^&apos; to the column list and the contents
				if (columnList IS NOT NULL AND LENGTH(&apos;|&apos;||columnList||&apos;|&apos;) &gt; 2) then  --notEmpty
					set columnList = columnList || sep;
				end if;
				set columnList = columnList ||contents;
	
				if (debug = &apos;Y&apos;) then
					call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;call parseArithmeticOperators(columnList=&apos;||NVL(columnList,&apos;null&apos;)||&apos;)&apos;);
				end if;
				-- parseArithmeticOperators(): Parse out the Arithmetic expression
				call /shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/parseArithmeticOperators(columnList,columnList);

				if (debug = &apos;Y&apos;) then
					call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;call isReservedColumnList(columnList=&apos;||NVL(columnList,&apos;null&apos;)||&apos;)&apos;);
				end if;
				-- isReservedColumnList(): Parse out the reserved words
				call /shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/isReservedColumnList(columnList,columnList);
			end if;
		end if;
		-- DEBUG
		if (debug = &apos;Y&apos;) then
			call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;columnList=[&apos;||NVL(columnList,&apos;null&apos;)||&apos;]&apos;);
		end if;
		set j = j + 1;
	end while;
--------------------------------
-- FINALIZE COLUMN LIST:
--------------------------------
	-- removeColumnListDuplicates(): Remove column list duplicates
	call /shared/ASAssets/BestPractices_v81/Procedures/sqlParser/utility/removeColumnListDuplicates(columnList,columnList);

	-- DEBUG
	if (debug = &apos;Y&apos;) then
		call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debug,&apos;Return columnList=[&apos;||columnList||&apos;] functionList=[&apos;||functionList||&apos;]&apos;);
	end if;
	if (debugTime = &apos;Y&apos;) then
		call /shared/ASAssets/Utilities/log/logDebugMessage(moduleName,debugTime,&apos;duration=&apos;||cast(CURRENT_TIMESTAMP - startTime as varchar)||&apos; recurseDepth=&apos;||recurseDepth||&apos;  columnList=&apos;||NVL(columnList,&apos;null&apos;));
	end if;
END</attribute>
  <attribute name="creationDate" type="LONG">0</attribute>
  <attribute name="creatorUserDomain" type="STRING"/>
  <attribute name="creatorUserName" type="STRING"/>
  <attribute name="explicitly.designed" type="BOOLEAN">false</attribute>
  <attribute name="impactLevel" type="INTEGER">0</attribute>
  <attribute name="impactMessage" type="NULL"/>
  <attribute name="lastModifiedDate" type="LONG">1557255222723</attribute>
  <attribute name="lastModifiedUserDomain" type="STRING">composite</attribute>
  <attribute name="lastModifiedUserName" type="STRING">admin</attribute>
  <attribute name="model" type="NULL"/>
  <attribute name="native_only" type="STRING">false</attribute>
  <attribute name="references" type="NULL"/>
</metadata>