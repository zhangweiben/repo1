<?xml version="1.1" encoding="UTF-8"?>
<!-- salt:44831da2-fa57-48b1-b3e8-4297d727cb06 -->
<metadata name="generateDatasourceListXMLInsertDB" path="/shared/ASAssets/BestPractices_v81/Procedures/generateDatasourceListXMLInsertDB" type="PROCEDURE" subtype="SQL_SCRIPT_PROCEDURE" changeToken="0">
  <annotation>(c) 2017 TIBCO Software Inc.  All rights reserved.
	
	Except as specified below, this software is licensed pursuant to the Eclipse Public License v. 1.0.
	The details can be found in the file LICENSE.
	
	The following proprietary files are included as a convenience, and may not be used except pursuant
	to valid license to Composite Information Server or TIBCO® Data Virtualization Server:
	csadmin-XXXX.jar, csarchive-XXXX.jar, csbase-XXXX.jar, csclient-XXXX.jar, cscommon-XXXX.jar,
	csext-XXXX.jar, csjdbc-XXXX.jar, csserverutil-XXXX.jar, csserver-XXXX.jar, cswebapi-XXXX.jar,
	and customproc-XXXX.jar (where -XXXX is an optional version number).  Any included third party files
	are licensed under the terms contained in their own accompanying LICENSE files, generally named .LICENSE.txt.
	
	This software is licensed AS-IS. Support for this software is not covered by standard maintenance agreements with TIBCO.
	If you would like to obtain assistance with this software, such assistance may be obtained through a separate paid consulting
	agreement with TIBCO.</annotation>
  <parameters>
    <parameter name="performInsertUpdate" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="refreshCache" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="sourceResource" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="generateLogicalNames" direction="IN" nullable="true">
      <datatype name="BIT" type="INTEGER" minValue="0" maxValue="1"/>
    </parameter>
    <parameter name="layerType" direction="IN" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="inGroupIds" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="inDerivedFilterPath" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="startingFolderXML" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="ConfigParamsXML" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="result" direction="OUT" nullable="true">
      <datatype name="DataSourceRowV2Row" type="TABLE" refId="1">
        <element name="DataSource">
          <datatype name="VARCHAR" type="STRING" maxLength="255"/>
        </element>
        <element name="ProjectFolderName">
          <datatype name="VARCHAR" type="STRING" maxLength="255"/>
        </element>
        <element name="GreatGrandParentName">
          <datatype name="VARCHAR" type="STRING" maxLength="255"/>
        </element>
        <element name="GrandParentName">
          <datatype name="VARCHAR" type="STRING" maxLength="255"/>
        </element>
        <element name="ParentName">
          <datatype name="VARCHAR" type="STRING" maxLength="255"/>
        </element>
        <element name="ContainerName">
          <datatype name="VARCHAR" type="STRING" maxLength="255"/>
        </element>
        <element name="PhysicalName">
          <datatype name="VARCHAR" type="STRING" maxLength="255"/>
        </element>
        <element name="NativeType">
          <datatype name="VARCHAR" type="STRING" maxLength="255"/>
        </element>
        <element name="LogicalName">
          <datatype name="VARCHAR" type="STRING" maxLength="255"/>
        </element>
        <element name="LogicalType">
          <datatype name="VARCHAR" type="STRING" maxLength="255"/>
        </element>
        <element name="LogicalTransformation">
          <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
        </element>
        <element name="LogicalDefinition">
          <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
        </element>
        <element name="LogicalPath">
          <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
        </element>
        <element name="Duration">
          <datatype name="IntervalDay" type="INTERVAL_DAY" intervalMode="INTERVAL_HOUR_TO_SECOND" intervalPrecision="2" fractionalSecondPrecision="6"/>
        </element>
      </datatype>
    </parameter>
  </parameters>
  <security>
    <owner user="admin" domain="composite"/>
    <privilege group="all" domain="composite" privileges="READ"/>
  </security>
  <dependency target="/lib/debug/Print" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="textToPrint" direction="IN">
        <datatype referenceDefinitionSet="/lib/util/System" referenceType="Text" type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/lib/resource/RefreshResourceCacheSynchronously" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="path" direction="IN">
        <datatype referenceDefinitionSet="/lib/resource/ResourceDefs" referenceType="ResourcePath" type="STRING" maxLength="4096"/>
      </element>
      <element name="type" direction="IN">
        <datatype referenceDefinitionSet="/lib/resource/ResourceDefs" referenceType="ResourceType" type="STRING" maxLength="40"/>
      </element>
      <element name="pollingInterval" direction="IN">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/lib/util/GetEnvironment" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="variableName" direction="IN">
        <datatype referenceDefinitionSet="/lib/util/System" referenceType="PropertyName" type="STRING" maxLength="255"/>
      </element>
      <element name="result" direction="OUT">
        <datatype referenceDefinitionSet="/lib/util/System" referenceType="PropertyValue" type="STRING" maxLength="4096"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/BestPractices_v81/DataSource/CommonModelCache/ciscache/common_model_v3" type="TABLE">
    <datatype type="TABLE" refId="1">
      <element name="ResourceId" nullable="false">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
      <element name="DataSource">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="ProjectFolderName">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="GreatGrandParentName">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="GrandParentName">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="ParentName">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="ContainerName">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="PhysicalName">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="NativeType">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="LogicalName">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="LogicalType">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="LogicalTransformation">
        <datatype type="STRING" maxLength="1024"/>
      </element>
      <element name="LogicalDefinition">
        <datatype type="STRING" maxLength="32767"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/BestPractices_v81/DataSource/common_model_v3" type="TABLE">
    <datatype type="TABLE" refId="1">
      <element name="ResourceId">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
      <element name="DataSource">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="ProjectFolderName">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="GreatGrandParentName">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="GrandParentName">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="ParentName">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="ContainerName">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="PhysicalName">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="NativeType">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="LogicalName">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="LogicalType">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="LogicalTransformation">
        <datatype type="STRING" maxLength="1024"/>
      </element>
      <element name="LogicalDefinition">
        <datatype type="STRING" maxLength="32767"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/BestPractices_v81/Procedures/TypeDefinitions" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1"></datatype>
  </dependency>
  <dependency target="/shared/ASAssets/BestPractices_v81/Procedures/generateDatasourceListXML" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="sourceResource" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="generateLogicalNames" direction="IN">
        <datatype type="INTEGER" minValue="0" maxValue="1"/>
      </element>
      <element name="layerType" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="inGroupIds" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="inDerivedFilterPath" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="inStartingFolderExtendedXML" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="ConfigParamsXML" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="resultPipe" direction="OUT">
        <datatype type="TABLE" refId="2">
          <element name="DataSource">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="ProjectFolderName">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="GreatGrandParentName">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="GrandParentName">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="ParentName">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="ContainerName">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="PhysicalName">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="NativeType">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="LogicalName">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="LogicalType">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="LogicalTransformation">
            <datatype type="STRING" maxLength="2147483647"/>
          </element>
          <element name="LogicalDefinition">
            <datatype type="STRING" maxLength="2147483647"/>
          </element>
          <element name="LogicalPath">
            <datatype type="STRING" maxLength="2147483647"/>
          </element>
          <element name="Duration">
            <datatype type="INTERVAL_DAY" intervalMode="INTERVAL_HOUR_TO_SECOND" intervalPrecision="2" fractionalSecondPrecision="6"/>
          </element>
        </datatype>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/BestPractices_v81/Procedures/xmlGetNodeValue" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="tagName" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="inXMLDoc" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="resultValue" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/BestPractices_v81/_ProjectMaintenance/defaultValues" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1"></datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/repository/getResourceCacheConfigCursor" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="inResourcePath" direction="IN">
        <datatype referenceDefinitionSet="/lib/resource/ResourceDefs" referenceType="ResourcePath" type="STRING" maxLength="4096"/>
      </element>
      <element name="inType" direction="IN">
        <datatype referenceDefinitionSet="/lib/resource/ResourceDefs" referenceType="ResourceType" type="STRING" maxLength="40"/>
      </element>
      <element name="result" direction="OUT">
        <datatype type="TABLE" refId="2">
          <element name="configured">
            <datatype type="INTEGER" minValue="0" maxValue="1"/>
          </element>
          <element name="enabled">
            <datatype type="INTEGER" minValue="0" maxValue="1"/>
          </element>
          <element name="cachePolicy">
            <datatype type="STRING" maxLength="32768"/>
          </element>
          <element name="storageMode">
            <datatype type="STRING" maxLength="32768"/>
          </element>
          <element name="storageDataSourcePath">
            <datatype type="STRING" maxLength="32768"/>
          </element>
          <element name="storageTargetName">
            <datatype type="STRING" maxLength="32768"/>
          </element>
          <element name="storagePath">
            <datatype type="STRING" maxLength="32768"/>
          </element>
          <element name="storageType">
            <datatype type="STRING" maxLength="32768"/>
          </element>
          <element name="refreshMode">
            <datatype type="STRING" maxLength="32768"/>
          </element>
          <element name="scheduleMode">
            <datatype type="STRING" maxLength="32768"/>
          </element>
          <element name="startTime">
            <datatype type="DATETIME"/>
          </element>
          <element name="fromTimeInADay">
            <datatype type="INTEGER"/>
          </element>
          <element name="endTimeInADay">
            <datatype type="INTEGER"/>
          </element>
          <element name="recurringDay">
            <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
          </element>
          <element name="interval">
            <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
          </element>
          <element name="period">
            <datatype type="STRING" maxLength="32768"/>
          </element>
          <element name="count">
            <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
          </element>
          <element name="isCluster">
            <datatype type="INTEGER" minValue="0" maxValue="1"/>
          </element>
          <element name="expirationPeriod">
            <datatype type="INTEGER"/>
          </element>
          <element name="clearRule">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="allOrNothing">
            <datatype type="INTEGER" minValue="0" maxValue="1"/>
          </element>
          <element name="incremental">
            <datatype type="INTEGER" minValue="0" maxValue="1"/>
          </element>
          <element name="storageBucketMode">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="storageBucketCatalog">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="storageBucketSchema">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="storageBucketPrefix">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="storageBucketNumBuckets">
            <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
          </element>
          <element name="storageDropCreateIdx">
            <datatype type="INTEGER" minValue="0" maxValue="1"/>
          </element>
          <element name="firstRefreshCallback">
            <datatype type="STRING" maxLength="32768"/>
          </element>
          <element name="secondRefreshCallback">
            <datatype type="STRING" maxLength="32768"/>
          </element>
        </datatype>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/string/getDelimitedOccurrence" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="1">
      <element name="inText" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="mode" direction="IN">
        <datatype type="STRING" minLength="1" maxLength="1"/>
      </element>
      <element name="delimiter" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="inOccurrence" direction="IN">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
      <element name="inTrimText" direction="IN">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
      <element name="result" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <attribute name="Script" type="STRING">/* 
	generateDatasourceListXMLInsertDB:

	This procedure generates the physcial to logical table and column mappings from the source datasource based on various input parameters such as 
		table case, column case, and table prefix.
	This procedure inserts the data into a table which gets used by the Best Practices Data Abstraction procedures to generate the views.
		The table is called common_model_v3 and is resident in the postgres cache database that comes with DV.
		Initially, it has to be created and the /shared/ASAssets/BestPractices_v81/DataSource/CommonModelCache data source has to be configured.
	Lastly, the common_model view is synchronously cached.

 	Input:
			-- Y=delete all project records.  N=do not delete (updates only).
			-- 	Delete all rows where /shared/ASAssets/BestPractices_v81/DataSource/common_model_v3/ProjectFolderName = &lt;project_name&gt;
			-- /lib/util/GetEnvironment(&apos;best.practices.performDeleteProjectRows&apos;,performDeleteProjectRows)
		performDeleteProjectRows

			-- Y=perform SQL operation.  N=do not perform SQL operation and only display results.
		IN performInsertUpdate			CHAR(1),

			-- Y=perform cache refres on common_model cache view.  N=do not perform cache refresh.
		IN refreshCache					CHAR(1),

			-- generate the logical names or physical names only
			-- 1 (TRUE) [default] - generate datasource list with logical names
			-- 0 (FALSE) - generate datasource list only with no logical names, 
			-- Generally this parameter is true.  However, it may be useful to set to 0 when generateMode=&apos;G&apos; and layerType=&apos;PM&apos; which allows
			--  the user to generate just the physical names for the physical metadata in the spreadsheet format as a way of initializing
			--  the physical names only.
		IN generateLogicalNames			BIT,

			-- Determines whether to retrieve names from the Common_Model_v2_file[1-3].xls spreadsheets or generate them and
			--   is only meaninfful when generateLogicalNames=1
			-- G=Generate the resource names 
			--   use &apos;G&apos; in conjunctionwith layerType=&apos;PM&apos; to generate the physical metadata names to the spreadsheet.
			--   This would be the strategy for initializing the Common_Model_v2_file[1-3].xls spreadsheet.  
			--   It is often useful to set the caseRule parameter to establish the type of logical names that you want to start with.
			-- R=Retrieve the resource name from a spreadsheet. (resources include PATH names, VIEW names AND COLUMN names)
			--   use &apos;R&apos; in conjunction with layerType=&apos;FV&apos;
		IN generateMode					CHAR(1),

			-- O=[default] Original_case - The word is not changed at all -- just pass it through as is
			-- j=javaCase - 1st word part is lower case, following word parts are 1st is letter is upper and remaining word part is lower with no separators
			-- C=CamelCase - 1st letter of each word part is upper case and remaining word part is lower with no separators
			-- T=Title_Case - 1st letter of each word part is upper case and remaining word part is lower with separators retained
			-- U=UPPER_CASE - All word parts are UPPER case with separtors retained
			-- l=lower_case - All word parts are lower case with separators retained
		IN tableCaseRule, -- (used when generateMode=&apos;G&apos;)

			-- O=[default] Original_case - The word is not changed at all -- just pass it through as is
			-- j=javaCase - 1st word part is lower case, following word parts are 1st is letter is upper and remaining word part is lower with no separators
			-- C=CamelCase - 1st letter of each word part is upper case and remaining word part is lower with no separators
			-- T=Title_Case - 1st letter of each word part is upper case and remaining word part is lower with separators retained
			-- U=UPPER_CASE - All word parts are UPPER case with separtors retained
			-- l=lower_case - All word parts are lower case with separators retained
		IN columnCaseRule, -- (used when generateMode=&apos;G&apos;)

			-- 0=[default] DO NOT perform alias rule lookup at all.  Word Part is passed through (default is 0)
			-- 1=Use alias rule and MATCH CASE exactly
			-- 2=Use alias rule and DO NOT MATCH CASE
			-- The &quot;AliasNameRuleSet()&quot; procedure is found in the folder /shared/&lt;project-folder&gt;/_scripts/Configure.
		IN useAliasRule, -- (used when generateMode=&apos;G&apos;)

			-- null/blank for no prefix or some value for a table prefix.
		IN tablePrefix, -- (used when generateMode=&apos;G&apos;)

			-- null/blank for no suffix or some value for a table suffix.
		IN tableSuffix, -- (used when generateMode=&apos;G&apos;)

			-- A formatted list of new columns to add to the end of the view.  The column will not be added if it already exists.
			-- The format is as follows:  column1&amp;&amp;type1&amp;&amp;value1//column2&amp;&amp;type2&amp;&amp;value2//column3&amp;&amp;type3&amp;&amp;value3
		IN newColumnList, --(used when generateMode=&apos;G&apos;)

			-- flag indicating whether to ignore or generate unsupported column types.  For example in Oracle an SDO spatial type gets imported into Composite as &apos;OTHER&apos;.
			-- 0/null (default) - ignore column type = &apos;OTHER&apos; and do not generate that column
			-- 1 - generate columns where the column type = &apos;OTHER&apos;
		IN generateUnsupportedColumnType BIT,

			-- specifies how the source resource will be matched against the resource being interrogated
			-- 0=fuzzy match - sourcePath + derivedFilterPath must simply be contained within resourcePath
			-- 1 (default)=exact match - sourcePath + derivedFilterPath must match exactly in resourcePath
		IN exactMatch					BIT,

			-- The list &quot;derivedFilterPath&quot; is a comma-separated list of resources and may be used with either generateToFolder (option 1) to groupId (option 2) 
			-- The path is derived by concatenating the partial filter path with the source path either from the sourceResource or of the designated layer type and groupId.
			-- The layerType and the groupId are used to filter the rows from the configureStartingFolders.  The source path is
			--    defined in configureStartingFolders per the layerType and groupId combination.
			--   e.g. layerType=CP and sourceFolderPath=/shared/BestPractices/DataAbstractionAbstractionSample/Application/Views
			--        The derivedFilterPath list=&quot;Orders_Closed,/Orders/Customers,Orders/Product&quot;
			--        Even though there are several other views in the /Orders folder under the /Application/Views only the ones specified
			--	      will be generated to the Application/Published.  Views directly under the source path do not require any qualifying path except the view name.
			--        Lastly, a leading &apos;/&apos; is not required but may be present if desired.
			-- Correlate the groupId position with the derivedFilterPath position
			--		derivedFilterPath=&quot;customers,orders&quot;,shippingmethods
			--                         |                     |
			--                         v                     v
			--		          groupId=ds_inventory.tutorial,ds_orders.tutorial
			-- If null, generate views from all source folders as directed by the sourceResource or &quot;configure starting folders&quot; and the designated layer type.
		IN derivedFilterPath			LONGVARCHAR,

			-- comma separated list of resource paths or partials paths to exclude.  This may be useful when a data source has been moved and it&apos;s index or foreign keys
			--	are pointing to another data source that does not exist anymore.  It may be necessary to exclude that path or paths.  If an exception is thrown during 
			--	execution, try excluding those paths.
			--	Values: /shared/MyPath/Physical/Metadata/MyDatasource
		IN excludeDsPathsList			LONGVARCHAR,
	
			-- The target folder in CIS to begin searching for views to generate the view list or
			-- a target view (exact path) to generate for.
			-- If this is set it supercedes layerType, inGroupIDs and derivedFilterPath
		IN sourceResource				LONGVARCHAR,

			-- This is an alternative entry point for this method.  If this is set then layerType,inGroupIds and inDerivedFilterPath are ignored
		startingFolderXML				LONGVARCHAR,

			-- The XML of configuration parameters.  A full description can be found in /generationScripts/Configure/ConfigureParams
		IN ConfigParamsXML 				LONGVARCHAR

	Output:
		OUT result						PIPE /shared/ASAssets/BestPractices_v81/Procedures/TypeDefinitions.DataSourceRowV2Row
			DataSource 					VARCHAR(255), -- The name of the data source in composite (data lineage-used resources)
			ProjectFolderName			VARCHAR(255), -- The project folder name is the last name found in the defaultValues.basePath for a project.
			--[NOT CURRENTLY IMPLEMENTED] Published	VARCHAR(255), -- Indicates whether this element is published in composite (data lineage-dependent resources)
			GreatGrandParentName		VARCHAR(255), -- The name of the great grand parent container (data source name)
			GrandParentName				VARCHAR(255), -- The name of the grand parent container (catalog name)
			ParentName 					VARCHAR(255), -- The name of the parent container - (schema name)
			ContainerName 				VARCHAR(255), -- The name of the container - parent to the resource (table name)
			PhysicalName				VARCHAR(255), -- The physical column name (a.k.a. column name)
			NativeType					VARCHAR(255), -- The native  type (a.k.a. table/view alias)
			LogicalName					VARCHAR(255), -- The logical column name (a.k.a. table/view alias)
			LogicalType 				VARCHAR(255), -- The logical column type
			LogicalTransformation		LONGVARCHAR,  -- The logical column transformation excluding outer cast statement
			LogicalDefinition			LONGVARCHAR,  -- The logical resource definition (a.k.a. view/table/column annotation)
			LogicalPath					LONGVARCHAR,  -- The logical resource (view) path
			Duration					INTERVAL HOUR TO SECOND -- The time it takes to process a view
	
	Modified Date:	Modified By:		DV Version:		Reason:
	01/23/2019		Mike Tinius			8.0.0			Created new to generate physical to logical table and column mappings and insert into a table.
	04/15/2019		Mike Tinius			7.0.8			B.P. 2019.200: Added scriptsPath for flexibility of the location of the _scripts folder.
																	   Changed custom functions to explicit paths.
	06/12/2019		Mike Tinius			7.0.8			B.P. 2019.200: Derived the new generateDatasourceListXMLInsertDB from generateDatasourceListInsertDB to eliminate vector usage.

	(c) 2017 TIBCO Software Inc.  All rights reserved.
	
	Except as specified below, this software is licensed pursuant to the Eclipse Public License v. 1.0.
	The details can be found in the file LICENSE.
	
	The following proprietary files are included as a convenience, and may not be used except pursuant
	to valid license to Composite Information Server or TIBCO® Data Virtualization Server:
	csadmin-XXXX.jar, csarchive-XXXX.jar, csbase-XXXX.jar, csclient-XXXX.jar, cscommon-XXXX.jar,
	csext-XXXX.jar, csjdbc-XXXX.jar, csserverutil-XXXX.jar, csserver-XXXX.jar, cswebapi-XXXX.jar,
	and customproc-XXXX.jar (where -XXXX is an optional version number).  Any included third party files
	are licensed under the terms contained in their own accompanying LICENSE files, generally named .LICENSE.txt.
	
	This software is licensed AS-IS. Support for this software is not covered by standard maintenance agreements with TIBCO.
	If you would like to obtain assistance with this software, such assistance may be obtained through a separate paid consulting
	agreement with TIBCO.

*/
PROCEDURE generateDatasourceListXMLInsertDB(
		-- Y=perform SQL operation.  N=do not perform SQL operation and only display results.
	IN performInsertUpdate			CHAR(1),

		-- Y=perform SQL operation.  N=do not perform SQL operation and only display results.
	IN refreshCache					CHAR(1),

		-- The source folder in CIS to begin searching for views to generate the view list or
		-- a source view (exact path) to generate for.
		-- If this is set it supercedes layerType, inGroupIDs and derivedFilterPath
	IN sourceResource				LONGVARCHAR,

		-- 0 (FALSE) - generate datasource list only with no logical names, 
    	-- 1 (TRUE) - generate datasource list with logical names
   	IN generateLogicalNames			BIT,

	-- If sourceResource is blank, then layerType, inGroupIds must be set with derivedFilterPath being optional
		-- PM=Physical Metadata - generateDatasourceList physical metadata tables
		-- FV=Formatting Views 	- generateDatasourceList formatting views
		-- BV=Business Views 	- generateDatasourceList business views (only single source)
		-- LV=Logical Views 	- generateDatasourceList logical views (only single source)
		-- CV=Client Views 		- generateDatasourceList client views (only single source)
		-- CP=Client Published 	- generateDatasourceList client published views (only single source)
   	IN layerType					VARCHAR,

		-- This is a comma separate list group ids to process from the configureStartingFolders.
		-- Pass in null to select all groupIds.
	IN inGroupIds					LONGVARCHAR,

		-- The list &quot;derivedFilterPath&quot; is a comma-separated list of resources and may be used with either generateToFolder (option 1) to groupId (option 2) 
		-- The path is derived by concatenating the partial filter path with the source path of the designated layer type.
		-- The layerType and the groupId are used to filter the rows from the configureStartingFolders.  The source path is
		--    defined in configureStartingFolders per the layerType and groupId combination.
		--   e.g. layerType=CP and sourceFolderPath=/shared/BestPractices/DataAbstractionSample/Application/Views
		--        The derivedFilterPath list=Orders_Closed,/Orders/Customers,Orders/Product
		--        Even though there are several other views in the /Orders folder under the Client_Views only the ones specified
		--	      will be generated to the Client_Published.  Views directly under the source path do not require any qualifying path except the view name.
		--        Lastly, a leading &apos;/&apos; is not required but may be present if desired.
		-- Correlate the groupId position with the derivedFilterPath position
		--		derivedFilterPath=&quot;customers,orders&quot;,shippingmethods
		--                         |                     |
		--                         v                     v
		--		          groupId=ds_inventory.tutorial,ds_orders.tutorial
		-- If null, generate views from all source folders as directed by the &quot;configure starting folders&quot; and the designated layer type.
	IN inDerivedFilterPath			LONGVARCHAR,

		-- This is an alternative entry point for this method.  If this is set then layerType,inGroupIds and inDerivedFilterPath are ignored
	IN 	startingFolderXML			LONGVARCHAR,

		-- The XML of configuration parameters.  A full description can be found in /generationScripts/Configure/ConfigureParams
	IN ConfigParamsXML				LONGVARCHAR,

	OUT result						PIPE /shared/ASAssets/BestPractices_v81/Procedures/TypeDefinitions.DataSourceRowV2Row
)
BEGIN
	DECLARE debug					CHAR(1);	-- Y=debug on.  N=debug off.
	DECLARE moduleName				VARCHAR DEFAULT &apos;generateDatasourceListXMLInsertDB&apos;;
		-- Y=delete all project records.  N=do not delete (insert/updates only).
		-- 	Delete all rows where /shared/ASAssets/BestPractices_v81/DataSource/common_model_v3/ProjectFolderName = &lt;project_name&gt;
	DECLARE performDeleteProjectRows CHAR(1);
	DECLARE sqlStatement			LONGVARCHAR;
	DECLARE whereClause				LONGVARCHAR DEFAULT &apos;&apos;;
	DECLARE commonModelDatabasePath	VARCHAR DEFAULT /shared/ASAssets/BestPractices_v81/&quot;_ProjectMaintenance&quot;/defaultValues.commonModelDatabasePath;
	DECLARE commonModelViewPath		VARCHAR DEFAULT /shared/ASAssets/BestPractices_v81/&quot;_ProjectMaintenance&quot;/defaultValues.commonModelViewPath;
	DECLARE cacheRefresh			BOOLEAN DEFAULT false;
	DECLARE	curs			 		CURSOR (cnt INTEGER);
	DECLARE rowCount				INTEGER;
	DECLARE resourceName			VARCHAR(255);
	DECLARE startTime				TIMESTAMP DEFAULT CURRENT_TIMESTAMP;
	DECLARE endTime					TIMESTAMP;
	DECLARE duration				INTERVAL DAY TO SECOND;
	DECLARE rec						/shared/ASAssets/BestPractices_v81/Procedures/TypeDefinitions.DataSourceRowV2Row;
	DECLARE projectName				VARCHAR;

	-- Get environment variables
	call /lib/util/GetEnvironment(&apos;best.practices.performDeleteProjectRows&apos;,performDeleteProjectRows);
	SET performDeleteProjectRows = UPPER(performDeleteProjectRows);
	IF (performDeleteProjectRows IS NULL OR performDeleteProjectRows = &apos;NULL&apos; OR (performDeleteProjectRows &lt;&gt; &apos;Y&apos; AND performDeleteProjectRows &lt;&gt; &apos;N&apos;)) THEN
		SET performDeleteProjectRows = &apos;N&apos;;	-- set the default value
	END IF;

	-- Set local Configuration parameters	
	call /shared/ASAssets/BestPractices_v81/Procedures/xmlGetNodeValue(&apos;debug&apos;, ConfigParamsXML, debug);

	-- Delete all rows for this project if instructed to.
	IF (performDeleteProjectRows IS NOT NULL AND UPPER(performDeleteProjectRows) = &apos;Y&apos;) THEN
		CALL /shared/ASAssets/BestPractices_v81/Procedures/xmlGetNodeValue(&apos;basePath&apos;, ConfigParamsXML, projectName);
		CALL /shared/ASAssets/Utilities/string/getDelimitedOccurrence(projectName, &apos;R&apos;, &apos;/&apos;, 1, 0, projectName);
		-- Remove any double quotes surrounding the project name
		SET projectName = REPLACE(projectName, &apos;&quot;&apos;, &apos;&apos;);
		IF (projectName IS NOT NULL AND LENGTH(TRIM(projectName)) &gt; 0) THEN
			IF (UPPER(debug) = &apos;Y&apos;) THEN
				CALL PRINT(moduleName||&apos; : Delete Action:  DELETE FROM /shared/ASAssets/BestPractices_v81/DataSource/common_model_v3 WHERE ProjectFolderName = &apos;&apos;&apos;||projectName||&apos;&apos;&apos;&apos;);
			END IF;
			BEGIN INDEPENDENT TRANSACTION
				DELETE FROM /shared/ASAssets/BestPractices_v81/DataSource/common_model_v3
					WHERE ProjectFolderName = projectName;
			END;
		ELSE
			IF (UPPER(debug) = &apos;Y&apos;) THEN
				CALL PRINT(moduleName||&apos; : Delete Action:  NONE. projectName=&apos;||NVL(projectName,&apos;null&apos;));
			END IF;
		END IF;
	ELSE
		IF (UPPER(debug) = &apos;Y&apos;) THEN
			CALL PRINT(moduleName||&apos; : Delete Action:  NONE. performDeleteProjectRows=&apos;||performDeleteProjectRows);
		END IF;
	END IF;

	/*********************************************
	 * Generate the Physical to Logical Mappings
	 *********************************************/
	FOR r AS
		SELECT
			CAST(CASE WHEN DataSource IS NOT NULL AND INSTR(DataSource,&apos;&quot;&apos;) = 1 AND INSTR(REVERSE(DataSource),&apos;&quot;&apos;) = 1 THEN SUBSTR(DataSource, 2, LENGTH(DataSource)-2)
				 ELSE DataSource
				 END AS VARCHAR(255)) DataSource,
			CAST(CASE WHEN ProjectFolderName IS NOT NULL AND INSTR(ProjectFolderName,&apos;&quot;&apos;) = 1 AND INSTR(REVERSE(ProjectFolderName),&apos;&quot;&apos;) = 1 THEN SUBSTR(ProjectFolderName, 2, LENGTH(ProjectFolderName)-2)
				 ELSE ProjectFolderName
				 END AS VARCHAR(255)) ProjectFolderName,
			CAST(CASE WHEN GreatGrandParentName IS NOT NULL AND INSTR(GreatGrandParentName,&apos;&quot;&apos;) = 1 AND INSTR(REVERSE(GreatGrandParentName),&apos;&quot;&apos;) = 1 THEN SUBSTR(GreatGrandParentName, 2, LENGTH(GreatGrandParentName)-2)
				 ELSE GreatGrandParentName
				 END AS VARCHAR(255)) GreatGrandParentName,
			CAST(CASE WHEN GrandParentName IS NOT NULL AND INSTR(GrandParentName,&apos;&quot;&apos;) = 1 AND INSTR(REVERSE(GrandParentName),&apos;&quot;&apos;) = 1 THEN SUBSTR(GrandParentName, 2, LENGTH(GrandParentName)-2)
				 ELSE GrandParentName
				 END AS VARCHAR(255)) GrandParentName,
			CAST(CASE WHEN ParentName IS NOT NULL AND INSTR(ParentName,&apos;&quot;&apos;) = 1 AND INSTR(REVERSE(ParentName),&apos;&quot;&apos;) = 1 THEN SUBSTR(ParentName, 2, LENGTH(ParentName)-2)
				 ELSE ParentName
				 END AS VARCHAR(255)) ParentName,
			CAST(CASE WHEN ContainerName IS NOT NULL AND INSTR(ContainerName,&apos;&quot;&apos;) = 1 AND INSTR(REVERSE(ContainerName),&apos;&quot;&apos;) = 1 THEN SUBSTR(ContainerName, 2, LENGTH(ContainerName)-2)
				 ELSE ContainerName
				 END AS VARCHAR(255)) ContainerName,
			CAST(CASE WHEN PhysicalName IS NOT NULL AND INSTR(PhysicalName,&apos;&quot;&apos;) = 1 AND INSTR(REVERSE(PhysicalName),&apos;&quot;&apos;) = 1 THEN SUBSTR(PhysicalName, 2, LENGTH(PhysicalName)-2)
				 ELSE PhysicalName
				 END AS VARCHAR(255)) PhysicalName,
			NativeType, 
			CAST(CASE WHEN LogicalName IS NOT NULL AND INSTR(LogicalName,&apos;&quot;&apos;) = 1 AND INSTR(REVERSE(LogicalName),&apos;&quot;&apos;) = 1 THEN SUBSTR(LogicalName, 2, LENGTH(LogicalName)-2)
				 ELSE LogicalName
				 END AS VARCHAR(255)) LogicalName,
			LogicalType,
			LogicalTransformation,
			LogicalDefinition,
			LogicalPath,
			Duration
			FROM /shared/ASAssets/BestPractices_v81/Procedures/generateDatasourceListXML(
					sourceResource, 	
						-- The source folder in CIS to begin searching for views to generate the view list or
						-- a source view (exact path) to generate for.
						-- If this is set it supercedes layerType, inGroupIDs and derivedFilterPath
					generateLogicalNames, 	
						-- 0 (FALSE) - generate datasource list only with no logical names, 
						-- 1 (TRUE) - generate datasource list with logical names
				
					-- If sourceResource is blank, then layerType, inGroupIds must be set with derivedFilterPath being optional
					layerType,
						-- PM=Physical Metadata - generateDatasourceList physical metadata tables
						-- FV=Formatting Views 	- generateDatasourceList formatting views
						-- BV=Business Views 	- generateDatasourceList business views (only single source)
						-- LV=Logical Views 	- generateDatasourceList logical views (only single source)
						-- CV=Client Views 		- generateDatasourceList client views (only single source)
						-- CP=Client Published 	- generateDatasourceList client published views (only single source)
					inGroupIds, 
						-- This is a comma separate list group ids to process from the configureStartingFolders.
						-- Pass in null to select all groupIds.
					inDerivedFilterPath, 
						-- The path is derived by concatenating the partial filter path with the source path of the designated layer type.
						-- The layerType and the groupId are used to filter the rows from the configureStartingFolders.  The source path is
						--    defined in configureStartingFolders per the layerType and groupId combination.
						--   e.g. layerType=CP and sourceFolderPath=/shared/BestPractices/DataAbstractionSample/Application/Views
						--        The derivedFilterPath list=Orders_Closed,/Orders/Customers,Orders/Product
						--        Even though there are several other views in the /Orders folder under the Client_Views only the ones specified
						--	      will be generated to the Client_Published.  Views directly under the source path do not require any qualifying path except the view name.
						--        Lastly, a leading &apos;/&apos; is not required but may be present if desired.
						-- If null, generate views from all source folders as directed by the &quot;configure starting folders&quot; and the designated layer type.
				
					startingFolderXML,
						-- This is an alternative entry point for this method.  If this is set then layerType,inGroupIds and inDerivedFilterPath are ignored
				
					ConfigParamsXML
			)
		WHERE DataSource &lt;&gt; &apos;FINISHED&apos; AND ProjectFolderName IS NOT NULL AND LENGTH(TRIM(ProjectFolderName)) &gt; 0
	DO
		SET rec = r; 
		-- column
		IF (rec.NativeType &lt;&gt; &apos;TABLE&apos; AND rec.NativeType &lt;&gt; &apos;PROCEDURE&apos;) THEN 
			-- Appply the column transformation
			IF (rec.LogicalTransformation IS NOT NULL AND LENGTH(TRIM(rec.LogicalTransformation)) &gt; 0 AND rec.LogicalName IS NOT NULL AND LENGTH(TRIM(rec.LogicalName)) &gt; 0) THEN
				SET rec.LogicalTransformation = &apos;CAST(&apos;||rec.LogicalTransformation||&apos; AS &apos;|| rec.LogicalType||&apos;)&apos;;
 
			ELSE
				IF (rec.LogicalType IS NOT NULL AND LENGTH(TRIM(rec.LogicalType)) &gt; 0) THEN
					SET rec.LogicalTransformation = &apos;CAST(? AS &apos;|| rec.LogicalType||&apos;)&apos;;
				END IF;
			END IF;
		END IF;
		INSERT INTO result VALUES(rec);

		-- Construct the base SQL statement
		set sqlStatement = &apos;SELECT COUNT(*) cnt FROM &apos;||commonModelDatabasePath||&apos; WHERE &apos;;
		set whereClause = &apos;&apos;;
	
		/***********************************
		 * Construct the where clause
		 ***********************************/
			-- AND ProjectFolderName
			if (rec.ProjectFolderName IS NOT NULL AND LENGTH(rec.ProjectFolderName) &gt; 0) then
				set resourceName = rec.ProjectFolderName;
				if (INSTR(resourceName, &apos;&apos;&apos;&apos;) &gt; 0) then
					set resourceName = REPLACE(resourceName, &apos;&apos;&apos;&apos;, &apos;&apos;&apos;&apos;&apos;&apos;);
				end if;
				if (INSTR(resourceName,&apos;&quot;&apos;) = 1 AND INSTR(REVERSE(resourceName),&apos;&quot;&apos;) = 1) THEN 
					set whereClause = whereClause || &apos; ProjectFolderName = &apos;||&apos;&apos;&apos;&apos;||SUBSTR(resourceName, 2, LENGTH(resourceName)-2)||&apos;&apos;&apos; &apos;;
				else
					set whereClause = whereClause || &apos; ProjectFolderName = &apos;||&apos;&apos;&apos;&apos;||resourceName||&apos;&apos;&apos; &apos;;
				end if;
			end if;
			-- AND GreatGrandParentName
			if (rec.GreatGrandParentName IS NOT NULL AND LENGTH(rec.GreatGrandParentName) &gt; 0) then
				set resourceName = rec.GreatGrandParentName;
				if (INSTR(resourceName, &apos;&apos;&apos;&apos;) &gt; 0) then
					set resourceName = REPLACE(resourceName, &apos;&apos;&apos;&apos;, &apos;&apos;&apos;&apos;&apos;&apos;);
				end if;
				if (INSTR(resourceName,&apos;&quot;&apos;) = 1 AND INSTR(REVERSE(resourceName),&apos;&quot;&apos;) = 1) THEN 
					set whereClause = whereClause || &apos; and GreatGrandParentName = &apos;||&apos;&apos;&apos;&apos;||SUBSTR(resourceName, 2, LENGTH(resourceName)-2)||&apos;&apos;&apos; &apos;;
				else
					set whereClause = whereClause || &apos; and GreatGrandParentName = &apos;||&apos;&apos;&apos;&apos;||resourceName||&apos;&apos;&apos; &apos;;
				end if;
			end if;
			-- AND GrandParentName
			if (rec.GrandParentName IS NOT NULL AND LENGTH(rec.GrandParentName) &gt; 0) then
				set resourceName = rec.GrandParentName;
				if (INSTR(resourceName, &apos;&apos;&apos;&apos;) &gt; 0) then
					set resourceName = REPLACE(resourceName, &apos;&apos;&apos;&apos;, &apos;&apos;&apos;&apos;&apos;&apos;);
				end if;
				if (INSTR(resourceName,&apos;&quot;&apos;) = 1 AND INSTR(REVERSE(resourceName),&apos;&quot;&apos;) = 1) THEN 
					set whereClause = whereClause || &apos; and GrandParentName = &apos;||&apos;&apos;&apos;&apos;||SUBSTR(resourceName, 2, LENGTH(resourceName)-2)||&apos;&apos;&apos; &apos;;
				else
					set whereClause = whereClause || &apos; and GrandParentName = &apos;||&apos;&apos;&apos;&apos;||resourceName||&apos;&apos;&apos; &apos;;
				end if;
			end if;
			-- AND ParentName
			if (rec.ParentName IS NOT NULL AND LENGTH(rec.ParentName) &gt; 0) then
				set resourceName = rec.ParentName;
				if (INSTR(resourceName, &apos;&apos;&apos;&apos;) &gt; 0) then
					set resourceName = REPLACE(resourceName, &apos;&apos;&apos;&apos;, &apos;&apos;&apos;&apos;&apos;&apos;);
				end if;
				if (INSTR(resourceName,&apos;&quot;&apos;) = 1 AND INSTR(REVERSE(resourceName),&apos;&quot;&apos;) = 1) THEN 
					set whereClause = whereClause || &apos; and ParentName = &apos;||&apos;&apos;&apos;&apos;||SUBSTR(resourceName, 2, LENGTH(resourceName)-2)||&apos;&apos;&apos; &apos;;
				else
					set whereClause = whereClause || &apos; and ParentName = &apos;||&apos;&apos;&apos;&apos;||resourceName||&apos;&apos;&apos;&apos;;
				end if;
			end if;
			-- ContainerName
			if (rec.ContainerName IS NOT NULL AND LENGTH(rec.ContainerName) &gt; 0) then
				set resourceName = rec.ContainerName;
				if (INSTR(resourceName, &apos;&apos;&apos;&apos;) &gt; 0) then
					set resourceName = REPLACE(resourceName, &apos;&apos;&apos;&apos;, &apos;&apos;&apos;&apos;&apos;&apos;);
				end if;
				if (INSTR(resourceName,&apos;&quot;&apos;) = 1 AND INSTR(REVERSE(resourceName),&apos;&quot;&apos;) = 1) THEN 
					set whereClause = whereClause || &apos; and ContainerName = &apos;||&apos;&apos;&apos;&apos;||SUBSTR(resourceName, 2, LENGTH(resourceName)-2)||&apos;&apos;&apos; &apos;;
				else
					set whereClause = whereClause || &apos; and ContainerName = &apos;||&apos;&apos;&apos;&apos;||resourceName||&apos;&apos;&apos; &apos;;
				end if;
			end if;
			-- PhysicalName
			if (rec.PhysicalName IS NOT NULL AND LENGTH(rec.PhysicalName) &gt; 0) then
				set resourceName = rec.PhysicalName;
				if (INSTR(resourceName, &apos;&apos;&apos;&apos;) &gt; 0) then
					set resourceName = REPLACE(resourceName, &apos;&apos;&apos;&apos;, &apos;&apos;&apos;&apos;&apos;&apos;);
				end if;
				if (INSTR(resourceName,&apos;&quot;&apos;) = 1 AND INSTR(REVERSE(resourceName),&apos;&quot;&apos;) = 1) THEN 
					set whereClause = whereClause || &apos; and PhysicalName = &apos;||&apos;&apos;&apos;&apos;||SUBSTR(resourceName, 2, LENGTH(resourceName)-2)||&apos;&apos;&apos; &apos;;
				else
					set whereClause = whereClause || &apos; and PhysicalName = &apos;||&apos;&apos;&apos;&apos;||resourceName||&apos;&apos;&apos; &apos;;
				end if;
			else
				if (rec.LogicalName IS NOT NULL AND LENGTH(rec.LogicalName) &gt; 0) then
					set resourceName = rec.LogicalName;
					if (INSTR(resourceName, &apos;&apos;&apos;&apos;) &gt; 0) then
						set resourceName = REPLACE(resourceName, &apos;&apos;&apos;&apos;, &apos;&apos;&apos;&apos;&apos;&apos;);
					end if;
					if (INSTR(resourceName,&apos;&quot;&apos;) = 1 AND INSTR(REVERSE(resourceName),&apos;&quot;&apos;) = 1) THEN 
						set whereClause = whereClause || &apos; and LogicalName = &apos;||&apos;&apos;&apos;&apos;||SUBSTR(resourceName, 2, LENGTH(resourceName)-2)||&apos;&apos;&apos; &apos;;
					else
						set whereClause = whereClause || &apos; and LogicalName = &apos;||&apos;&apos;&apos;&apos;||resourceName||&apos;&apos;&apos; &apos;;
					end if;
					set whereClause = whereClause || &apos; and (PhysicalName IS NULL OR length(PhysicalName) = 0)&apos;;
				end if;
            end if;

		SET sqlStatement = sqlStatement || &apos; &apos; || whereClause;	
		IF (UPPER(debug) = &apos;Y&apos;) THEN
			CALL PRINT(moduleName||&apos; : Select Statement : &apos;|| CHR(10) || NVL(sqlStatement,&apos;null&apos;));
		END IF;

		SET rowCount = 0;	
		OPEN curs for sqlStatement;
		FOR c AS curs DO
			SET rowCount = c.cnt;
		END FOR;
		IF (rowCount = 0) THEN
			-- Insert the row
			SET sqlStatement = &apos;INSERT INTO &apos;||commonModelDatabasePath||
			&apos; (DataSource, ProjectFolderName, GreatGrandParentName, GrandParentName, ParentName, ContainerName, PhysicalName, NativeType, LogicalName, LogicalType, LogicalTransformation, LogicalDefinition)&apos;||
			&apos; VALUES(&apos;||
				&apos;&apos;&apos;&apos;||TRIM(NVL(rec.DataSource,&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;&apos;&apos;&apos;||TRIM(NVL(rec.ProjectFolderName,&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;&apos;&apos;&apos;||TRIM(NVL(rec.GreatGrandParentName,&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;&apos;&apos;&apos;||TRIM(NVL(rec.GrandParentName,&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;&apos;&apos;&apos;||TRIM(NVL(rec.ParentName,&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;&apos;&apos;&apos;||TRIM(NVL(rec.ContainerName,&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;&apos;&apos;&apos;||TRIM(NVL(rec.PhysicalName,&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;&apos;&apos;&apos;||TRIM(NVL(rec.NativeType,&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;&apos;&apos;&apos;||TRIM(NVL(rec.LogicalName,&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;&apos;&apos;&apos;||TRIM(NVL(REPLACE(rec.LogicalType,&apos;&apos;&apos;&apos;,&apos;&apos;&apos;&apos;&apos;&apos;),&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;&apos;&apos;&apos;||TRIM(NVL(REPLACE(rec.LogicalTransformation,&apos;&apos;&apos;&apos;,&apos;&apos;&apos;&apos;&apos;&apos;),&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;&apos;&apos;&apos;||TRIM(NVL(rec.LogicalDefinition,&apos;  &apos;))||&apos;&apos;&apos;&apos;||
			&apos;)&apos;;
			IF (UPPER(debug) = &apos;Y&apos;) THEN
				CALL PRINT(moduleName||&apos; : Insert Statement:  &apos;|| CHR(10) || NVL(sqlStatement,&apos;null&apos;));
			END IF;
			-- Only insert the row if instructed
			IF (performInsertUpdate IS NOT NULL AND UPPER(performInsertUpdate) = &apos;Y&apos;) THEN
				BEGIN INDEPENDENT TRANSACTION
					EXECUTE IMMEDIATE sqlStatement;
				END;
			END IF;
		ELSEIF (rowCount = 1) THEN
			-- Update the row
			SET sqlStatement = &apos;UPDATE &apos;||commonModelDatabasePath||
				&apos;   SET &apos;||
				&apos;       DataSource = &apos;&apos;&apos;||TRIM(NVL(rec.DataSource,&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;       ProjectFolderName=&apos;&apos;&apos;||TRIM(NVL(rec.ProjectFolderName,&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;       GreatGrandParentName=&apos;&apos;&apos;||TRIM(NVL(rec.GreatGrandParentName,&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;       GrandParentName=&apos;&apos;&apos;||TRIM(NVL(rec.GrandParentName,&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;       ParentName=&apos;&apos;&apos;||TRIM(NVL(rec.ParentName,&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;       ContainerName=&apos;&apos;&apos;||TRIM(NVL(rec.ContainerName,&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;       PhysicalName=&apos;&apos;&apos;||TRIM(NVL(rec.PhysicalName,&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;       NativeType=&apos;&apos;&apos;||TRIM(NVL(rec.NativeType,&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;       LogicalName=&apos;&apos;&apos;||TRIM(NVL(rec.LogicalName,&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;       LogicalType=&apos;&apos;&apos;||TRIM(NVL(REPLACE(rec.LogicalType,&apos;&apos;&apos;&apos;,&apos;&apos;&apos;&apos;&apos;&apos;),&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;       LogicalTransformation=&apos;&apos;&apos;||TRIM(NVL(REPLACE(rec.LogicalTransformation,&apos;&apos;&apos;&apos;,&apos;&apos;&apos;&apos;&apos;&apos;),&apos;  &apos;))||&apos;&apos;&apos;,&apos;|| 
				&apos;       LogicalDefinition=&apos;&apos;&apos;||TRIM(NVL(rec.LogicalDefinition,&apos;  &apos;))||&apos;&apos;&apos;&apos;||
				&apos;WHERE &apos;||whereClause;
 
			IF (UPPER(debug) = &apos;Y&apos;) THEN
				CALL PRINT(moduleName||&apos; : Update Statement: &apos;|| CHR(10) || NVL(sqlStatement,&apos;null&apos;));
			END IF;
			-- Only update the row if instructed
			IF (performInsertUpdate IS NOT NULL AND UPPER(performInsertUpdate) = &apos;Y&apos;) THEN
				BEGIN INDEPENDENT TRANSACTION
					EXECUTE IMMEDIATE sqlStatement;
				END;
			END IF;
		ELSE
			-- Duplicate row
			CALL PRINT(&apos;The row is a duplicate row with a count=&apos;||rowCount);
		END IF;		
	END FOR;
 
	/*********************************************
	 * Refresh common_model cache
	 *********************************************/
	-- Make sure the common_model cache has been refreshed with the updates from the previous step
	IF (refreshCache IS NOT NULL AND UPPER(refreshCache) = &apos;Y&apos; AND performInsertUpdate IS NOT NULL AND UPPER(performInsertUpdate) = &apos;Y&apos;) THEN
		SET startTime = CURRENT_TIMESTAMP;
		FOR cache AS SELECT * FROM /shared/ASAssets/Utilities/repository/getResourceCacheConfigCursor(commonModelViewPath, &apos;TABLE&apos;) DO
			IF (cache.configured = 1 AND cache.enabled = 1) THEN
				SET cacheRefresh =  true;
			END IF;
		END FOR; 
		IF (cacheRefresh) THEN
			IF (UPPER(debug) = &apos;Y&apos;) THEN
				CALL PRINT(moduleName||&apos; : Refreshing the cache=&apos;||NVL(commonModelViewPath,&apos;null&apos;));
			END IF;
			CALL /lib/resource/RefreshResourceCacheSynchronously(commonModelViewPath, &apos;TABLE&apos;, 1000);
			IF (UPPER(debug) = &apos;Y&apos;) THEN
				SET endTime = CURRENT_TIMESTAMP;
				SET duration = endTime - startTime;
				CALL PRINT(moduleName||&apos; : Finished Refreshing the cache.  duration=&apos;||CAST(duration AS VARCHAR));
			END IF;
		END IF;
	ELSE
		IF (UPPER(debug) = &apos;Y&apos;) THEN
			CALL PRINT(moduleName||&apos; : No refresh scheduled.  performInsertUpdate=&apos;||NVL(performInsertUpdate,&apos;null&apos;));
		END IF;
	END IF; 
END </attribute>
  <attribute name="creationDate" type="LONG">1548189531537</attribute>
  <attribute name="creatorUserDomain" type="STRING">composite</attribute>
  <attribute name="creatorUserId" type="INTEGER">-1973</attribute>
  <attribute name="creatorUserName" type="STRING">admin</attribute>
  <attribute name="explicitly.designed" type="BOOLEAN">false</attribute>
  <attribute name="lastModifiedDate" type="LONG">1570164238389</attribute>
  <attribute name="lastModifiedUserDomain" type="STRING">na</attribute>
  <attribute name="lastModifiedUserId" type="INTEGER">-1973</attribute>
  <attribute name="lastModifiedUserName" type="STRING">asp5665</attribute>
  <attribute name="model" type="NULL"/>
  <attribute name="native_only" type="STRING">false</attribute>
  <attribute name="references" type="MAP">
    <item>
      <key type="STRING">9/263</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">9/450</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">10/504</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">10/537</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">10/258</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">9/542</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">10/250</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">9/514</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">10/531</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">10/477</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
  </attribute>
  <attribute name="resourceModifiedDateOnSourceCISSite" type="LONG">1548189531537</attribute>
</metadata>